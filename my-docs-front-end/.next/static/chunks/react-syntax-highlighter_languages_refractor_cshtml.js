"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["react-syntax-highlighter_languages_refractor_cshtml"],{

/***/ "(app-pages-browser)/./node_modules/refractor/lang/csharp.js":
/*!***********************************************!*\
  !*** ./node_modules/refractor/lang/csharp.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\nmodule.exports = csharp;\ncsharp.displayName = \"csharp\";\ncsharp.aliases = [\n    \"dotnet\",\n    \"cs\"\n];\nfunction csharp(Prism) {\n    ;\n    (function(Prism) {\n        /**\n     * Replaces all placeholders \"<<n>>\" of given pattern with the n-th replacement (zero based).\n     *\n     * Note: This is a simple text based replacement. Be careful when using backreferences!\n     *\n     * @param {string} pattern the given pattern.\n     * @param {string[]} replacements a list of replacement which can be inserted into the given pattern.\n     * @returns {string} the pattern with all placeholders replaced with their corresponding replacements.\n     * @example replace(/a<<0>>a/.source, [/b+/.source]) === /a(?:b+)a/.source\n     */ function replace(pattern, replacements) {\n            return pattern.replace(/<<(\\d+)>>/g, function(m, index) {\n                return \"(?:\" + replacements[+index] + \")\";\n            });\n        }\n        /**\n     * @param {string} pattern\n     * @param {string[]} replacements\n     * @param {string} [flags]\n     * @returns {RegExp}\n     */ function re(pattern, replacements, flags) {\n            return RegExp(replace(pattern, replacements), flags || \"\");\n        }\n        /**\n     * Creates a nested pattern where all occurrences of the string `<<self>>` are replaced with the pattern itself.\n     *\n     * @param {string} pattern\n     * @param {number} depthLog2\n     * @returns {string}\n     */ function nested(pattern, depthLog2) {\n            for(var i = 0; i < depthLog2; i++){\n                pattern = pattern.replace(/<<self>>/g, function() {\n                    return \"(?:\" + pattern + \")\";\n                });\n            }\n            return pattern.replace(/<<self>>/g, \"[^\\\\s\\\\S]\");\n        } // https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/\n        var keywordKinds = {\n            // keywords which represent a return or variable type\n            type: \"bool byte char decimal double dynamic float int long object sbyte short string uint ulong ushort var void\",\n            // keywords which are used to declare a type\n            typeDeclaration: \"class enum interface record struct\",\n            // contextual keywords\n            // (\"var\" and \"dynamic\" are missing because they are used like types)\n            contextual: \"add alias and ascending async await by descending from(?=\\\\s*(?:\\\\w|$)) get global group into init(?=\\\\s*;) join let nameof not notnull on or orderby partial remove select set unmanaged value when where with(?=\\\\s*{)\",\n            // all other keywords\n            other: \"abstract as base break case catch checked const continue default delegate do else event explicit extern finally fixed for foreach goto if implicit in internal is lock namespace new null operator out override params private protected public readonly ref return sealed sizeof stackalloc static switch this throw try typeof unchecked unsafe using virtual volatile while yield\"\n        } // keywords\n        ;\n        function keywordsToPattern(words) {\n            return \"\\\\b(?:\" + words.trim().replace(/ /g, \"|\") + \")\\\\b\";\n        }\n        var typeDeclarationKeywords = keywordsToPattern(keywordKinds.typeDeclaration);\n        var keywords = RegExp(keywordsToPattern(keywordKinds.type + \" \" + keywordKinds.typeDeclaration + \" \" + keywordKinds.contextual + \" \" + keywordKinds.other));\n        var nonTypeKeywords = keywordsToPattern(keywordKinds.typeDeclaration + \" \" + keywordKinds.contextual + \" \" + keywordKinds.other);\n        var nonContextualKeywords = keywordsToPattern(keywordKinds.type + \" \" + keywordKinds.typeDeclaration + \" \" + keywordKinds.other) // types\n        ;\n        var generic = nested(/<(?:[^<>;=+\\-*/%&|^]|<<self>>)*>/.source, 2) // the idea behind the other forbidden characters is to prevent false positives. Same for tupleElement.\n        ;\n        var nestedRound = nested(/\\((?:[^()]|<<self>>)*\\)/.source, 2);\n        var name = /@?\\b[A-Za-z_]\\w*\\b/.source;\n        var genericName = replace(/<<0>>(?:\\s*<<1>>)?/.source, [\n            name,\n            generic\n        ]);\n        var identifier = replace(/(?!<<0>>)<<1>>(?:\\s*\\.\\s*<<1>>)*/.source, [\n            nonTypeKeywords,\n            genericName\n        ]);\n        var array = /\\[\\s*(?:,\\s*)*\\]/.source;\n        var typeExpressionWithoutTuple = replace(/<<0>>(?:\\s*(?:\\?\\s*)?<<1>>)*(?:\\s*\\?)?/.source, [\n            identifier,\n            array\n        ]);\n        var tupleElement = replace(/[^,()<>[\\];=+\\-*/%&|^]|<<0>>|<<1>>|<<2>>/.source, [\n            generic,\n            nestedRound,\n            array\n        ]);\n        var tuple = replace(/\\(<<0>>+(?:,<<0>>+)+\\)/.source, [\n            tupleElement\n        ]);\n        var typeExpression = replace(/(?:<<0>>|<<1>>)(?:\\s*(?:\\?\\s*)?<<2>>)*(?:\\s*\\?)?/.source, [\n            tuple,\n            identifier,\n            array\n        ]);\n        var typeInside = {\n            keyword: keywords,\n            punctuation: /[<>()?,.:[\\]]/\n        } // strings & characters\n        ;\n        // https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#character-literals\n        // https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#string-literals\n        var character = /'(?:[^\\r\\n'\\\\]|\\\\.|\\\\[Uux][\\da-fA-F]{1,8})'/.source // simplified pattern\n        ;\n        var regularString = /\"(?:\\\\.|[^\\\\\"\\r\\n])*\"/.source;\n        var verbatimString = /@\"(?:\"\"|\\\\[\\s\\S]|[^\\\\\"])*\"(?!\")/.source;\n        Prism.languages.csharp = Prism.languages.extend(\"clike\", {\n            string: [\n                {\n                    pattern: re(/(^|[^$\\\\])<<0>>/.source, [\n                        verbatimString\n                    ]),\n                    lookbehind: true,\n                    greedy: true\n                },\n                {\n                    pattern: re(/(^|[^@$\\\\])<<0>>/.source, [\n                        regularString\n                    ]),\n                    lookbehind: true,\n                    greedy: true\n                }\n            ],\n            \"class-name\": [\n                {\n                    // Using static\n                    // using static System.Math;\n                    pattern: re(/(\\busing\\s+static\\s+)<<0>>(?=\\s*;)/.source, [\n                        identifier\n                    ]),\n                    lookbehind: true,\n                    inside: typeInside\n                },\n                {\n                    // Using alias (type)\n                    // using Project = PC.MyCompany.Project;\n                    pattern: re(/(\\busing\\s+<<0>>\\s*=\\s*)<<1>>(?=\\s*;)/.source, [\n                        name,\n                        typeExpression\n                    ]),\n                    lookbehind: true,\n                    inside: typeInside\n                },\n                {\n                    // Using alias (alias)\n                    // using Project = PC.MyCompany.Project;\n                    pattern: re(/(\\busing\\s+)<<0>>(?=\\s*=)/.source, [\n                        name\n                    ]),\n                    lookbehind: true\n                },\n                {\n                    // Type declarations\n                    // class Foo<A, B>\n                    // interface Foo<out A, B>\n                    pattern: re(/(\\b<<0>>\\s+)<<1>>/.source, [\n                        typeDeclarationKeywords,\n                        genericName\n                    ]),\n                    lookbehind: true,\n                    inside: typeInside\n                },\n                {\n                    // Single catch exception declaration\n                    // catch(Foo)\n                    // (things like catch(Foo e) is covered by variable declaration)\n                    pattern: re(/(\\bcatch\\s*\\(\\s*)<<0>>/.source, [\n                        identifier\n                    ]),\n                    lookbehind: true,\n                    inside: typeInside\n                },\n                {\n                    // Name of the type parameter of generic constraints\n                    // where Foo : class\n                    pattern: re(/(\\bwhere\\s+)<<0>>/.source, [\n                        name\n                    ]),\n                    lookbehind: true\n                },\n                {\n                    // Casts and checks via as and is.\n                    // as Foo<A>, is Bar<B>\n                    // (things like if(a is Foo b) is covered by variable declaration)\n                    pattern: re(/(\\b(?:is(?:\\s+not)?|as)\\s+)<<0>>/.source, [\n                        typeExpressionWithoutTuple\n                    ]),\n                    lookbehind: true,\n                    inside: typeInside\n                },\n                {\n                    // Variable, field and parameter declaration\n                    // (Foo bar, Bar baz, Foo[,,] bay, Foo<Bar, FooBar<Bar>> bax)\n                    pattern: re(/\\b<<0>>(?=\\s+(?!<<1>>|with\\s*\\{)<<2>>(?:\\s*[=,;:{)\\]]|\\s+(?:in|when)\\b))/.source, [\n                        typeExpression,\n                        nonContextualKeywords,\n                        name\n                    ]),\n                    inside: typeInside\n                }\n            ],\n            keyword: keywords,\n            // https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#literals\n            number: /(?:\\b0(?:x[\\da-f_]*[\\da-f]|b[01_]*[01])|(?:\\B\\.\\d+(?:_+\\d+)*|\\b\\d+(?:_+\\d+)*(?:\\.\\d+(?:_+\\d+)*)?)(?:e[-+]?\\d+(?:_+\\d+)*)?)(?:[dflmu]|lu|ul)?\\b/i,\n            operator: />>=?|<<=?|[-=]>|([-+&|])\\1|~|\\?\\?=?|[-+*/%&|^!=<>]=?/,\n            punctuation: /\\?\\.?|::|[{}[\\];(),.:]/\n        });\n        Prism.languages.insertBefore(\"csharp\", \"number\", {\n            range: {\n                pattern: /\\.\\./,\n                alias: \"operator\"\n            }\n        });\n        Prism.languages.insertBefore(\"csharp\", \"punctuation\", {\n            \"named-parameter\": {\n                pattern: re(/([(,]\\s*)<<0>>(?=\\s*:)/.source, [\n                    name\n                ]),\n                lookbehind: true,\n                alias: \"punctuation\"\n            }\n        });\n        Prism.languages.insertBefore(\"csharp\", \"class-name\", {\n            namespace: {\n                // namespace Foo.Bar {}\n                // using Foo.Bar;\n                pattern: re(/(\\b(?:namespace|using)\\s+)<<0>>(?:\\s*\\.\\s*<<0>>)*(?=\\s*[;{])/.source, [\n                    name\n                ]),\n                lookbehind: true,\n                inside: {\n                    punctuation: /\\./\n                }\n            },\n            \"type-expression\": {\n                // default(Foo), typeof(Foo<Bar>), sizeof(int)\n                pattern: re(/(\\b(?:default|sizeof|typeof)\\s*\\(\\s*(?!\\s))(?:[^()\\s]|\\s(?!\\s)|<<0>>)*(?=\\s*\\))/.source, [\n                    nestedRound\n                ]),\n                lookbehind: true,\n                alias: \"class-name\",\n                inside: typeInside\n            },\n            \"return-type\": {\n                // Foo<Bar> ForBar(); Foo IFoo.Bar() => 0\n                // int this[int index] => 0; T IReadOnlyList<T>.this[int index] => this[index];\n                // int Foo => 0; int Foo { get; set } = 0;\n                pattern: re(/<<0>>(?=\\s+(?:<<1>>\\s*(?:=>|[({]|\\.\\s*this\\s*\\[)|this\\s*\\[))/.source, [\n                    typeExpression,\n                    identifier\n                ]),\n                inside: typeInside,\n                alias: \"class-name\"\n            },\n            \"constructor-invocation\": {\n                // new List<Foo<Bar[]>> { }\n                pattern: re(/(\\bnew\\s+)<<0>>(?=\\s*[[({])/.source, [\n                    typeExpression\n                ]),\n                lookbehind: true,\n                inside: typeInside,\n                alias: \"class-name\"\n            },\n            /*'explicit-implementation': {\n// int IFoo<Foo>.Bar => 0; void IFoo<Foo<Foo>>.Foo<T>();\npattern: replace(/\\b<<0>>(?=\\.<<1>>)/, className, methodOrPropertyDeclaration),\ninside: classNameInside,\nalias: 'class-name'\n},*/ \"generic-method\": {\n                // foo<Bar>()\n                pattern: re(/<<0>>\\s*<<1>>(?=\\s*\\()/.source, [\n                    name,\n                    generic\n                ]),\n                inside: {\n                    function: re(/^<<0>>/.source, [\n                        name\n                    ]),\n                    generic: {\n                        pattern: RegExp(generic),\n                        alias: \"class-name\",\n                        inside: typeInside\n                    }\n                }\n            },\n            \"type-list\": {\n                // The list of types inherited or of generic constraints\n                // class Foo<F> : Bar, IList<FooBar>\n                // where F : Bar, IList<int>\n                pattern: re(/\\b((?:<<0>>\\s+<<1>>|record\\s+<<1>>\\s*<<5>>|where\\s+<<2>>)\\s*:\\s*)(?:<<3>>|<<4>>|<<1>>\\s*<<5>>|<<6>>)(?:\\s*,\\s*(?:<<3>>|<<4>>|<<6>>))*(?=\\s*(?:where|[{;]|=>|$))/.source, [\n                    typeDeclarationKeywords,\n                    genericName,\n                    name,\n                    typeExpression,\n                    keywords.source,\n                    nestedRound,\n                    /\\bnew\\s*\\(\\s*\\)/.source\n                ]),\n                lookbehind: true,\n                inside: {\n                    \"record-arguments\": {\n                        pattern: re(/(^(?!new\\s*\\()<<0>>\\s*)<<1>>/.source, [\n                            genericName,\n                            nestedRound\n                        ]),\n                        lookbehind: true,\n                        greedy: true,\n                        inside: Prism.languages.csharp\n                    },\n                    keyword: keywords,\n                    \"class-name\": {\n                        pattern: RegExp(typeExpression),\n                        greedy: true,\n                        inside: typeInside\n                    },\n                    punctuation: /[,()]/\n                }\n            },\n            preprocessor: {\n                pattern: /(^[\\t ]*)#.*/m,\n                lookbehind: true,\n                alias: \"property\",\n                inside: {\n                    // highlight preprocessor directives as keywords\n                    directive: {\n                        pattern: /(#)\\b(?:define|elif|else|endif|endregion|error|if|line|nullable|pragma|region|undef|warning)\\b/,\n                        lookbehind: true,\n                        alias: \"keyword\"\n                    }\n                }\n            }\n        }) // attributes\n        ;\n        var regularStringOrCharacter = regularString + \"|\" + character;\n        var regularStringCharacterOrComment = replace(/\\/(?![*/])|\\/\\/[^\\r\\n]*[\\r\\n]|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/|<<0>>/.source, [\n            regularStringOrCharacter\n        ]);\n        var roundExpression = nested(replace(/[^\"'/()]|<<0>>|\\(<<self>>*\\)/.source, [\n            regularStringCharacterOrComment\n        ]), 2) // https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/attributes/#attribute-targets\n        ;\n        var attrTarget = /\\b(?:assembly|event|field|method|module|param|property|return|type)\\b/.source;\n        var attr = replace(/<<0>>(?:\\s*\\(<<1>>*\\))?/.source, [\n            identifier,\n            roundExpression\n        ]);\n        Prism.languages.insertBefore(\"csharp\", \"class-name\", {\n            attribute: {\n                // Attributes\n                // [Foo], [Foo(1), Bar(2, Prop = \"foo\")], [return: Foo(1), Bar(2)], [assembly: Foo(Bar)]\n                pattern: re(/((?:^|[^\\s\\w>)?])\\s*\\[\\s*)(?:<<0>>\\s*:\\s*)?<<1>>(?:\\s*,\\s*<<1>>)*(?=\\s*\\])/.source, [\n                    attrTarget,\n                    attr\n                ]),\n                lookbehind: true,\n                greedy: true,\n                inside: {\n                    target: {\n                        pattern: re(/^<<0>>(?=\\s*:)/.source, [\n                            attrTarget\n                        ]),\n                        alias: \"keyword\"\n                    },\n                    \"attribute-arguments\": {\n                        pattern: re(/\\(<<0>>*\\)/.source, [\n                            roundExpression\n                        ]),\n                        inside: Prism.languages.csharp\n                    },\n                    \"class-name\": {\n                        pattern: RegExp(identifier),\n                        inside: {\n                            punctuation: /\\./\n                        }\n                    },\n                    punctuation: /[:,]/\n                }\n            }\n        }) // string interpolation\n        ;\n        var formatString = /:[^}\\r\\n]+/.source // multi line\n        ;\n        var mInterpolationRound = nested(replace(/[^\"'/()]|<<0>>|\\(<<self>>*\\)/.source, [\n            regularStringCharacterOrComment\n        ]), 2);\n        var mInterpolation = replace(/\\{(?!\\{)(?:(?![}:])<<0>>)*<<1>>?\\}/.source, [\n            mInterpolationRound,\n            formatString\n        ]) // single line\n        ;\n        var sInterpolationRound = nested(replace(/[^\"'/()]|\\/(?!\\*)|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/|<<0>>|\\(<<self>>*\\)/.source, [\n            regularStringOrCharacter\n        ]), 2);\n        var sInterpolation = replace(/\\{(?!\\{)(?:(?![}:])<<0>>)*<<1>>?\\}/.source, [\n            sInterpolationRound,\n            formatString\n        ]);\n        function createInterpolationInside(interpolation, interpolationRound) {\n            return {\n                interpolation: {\n                    pattern: re(/((?:^|[^{])(?:\\{\\{)*)<<0>>/.source, [\n                        interpolation\n                    ]),\n                    lookbehind: true,\n                    inside: {\n                        \"format-string\": {\n                            pattern: re(/(^\\{(?:(?![}:])<<0>>)*)<<1>>(?=\\}$)/.source, [\n                                interpolationRound,\n                                formatString\n                            ]),\n                            lookbehind: true,\n                            inside: {\n                                punctuation: /^:/\n                            }\n                        },\n                        punctuation: /^\\{|\\}$/,\n                        expression: {\n                            pattern: /[\\s\\S]+/,\n                            alias: \"language-csharp\",\n                            inside: Prism.languages.csharp\n                        }\n                    }\n                },\n                string: /[\\s\\S]+/\n            };\n        }\n        Prism.languages.insertBefore(\"csharp\", \"string\", {\n            \"interpolation-string\": [\n                {\n                    pattern: re(/(^|[^\\\\])(?:\\$@|@\\$)\"(?:\"\"|\\\\[\\s\\S]|\\{\\{|<<0>>|[^\\\\{\"])*\"/.source, [\n                        mInterpolation\n                    ]),\n                    lookbehind: true,\n                    greedy: true,\n                    inside: createInterpolationInside(mInterpolation, mInterpolationRound)\n                },\n                {\n                    pattern: re(/(^|[^@\\\\])\\$\"(?:\\\\.|\\{\\{|<<0>>|[^\\\\\"{])*\"/.source, [\n                        sInterpolation\n                    ]),\n                    lookbehind: true,\n                    greedy: true,\n                    inside: createInterpolationInside(sInterpolation, sInterpolationRound)\n                }\n            ],\n            char: {\n                pattern: RegExp(character),\n                greedy: true\n            }\n        });\n        Prism.languages.dotnet = Prism.languages.cs = Prism.languages.csharp;\n    })(Prism);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWZyYWN0b3IvbGFuZy9jc2hhcnAuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQUEsT0FBT0MsT0FBTyxHQUFHQztBQUNqQkEsT0FBT0MsV0FBVyxHQUFHO0FBQ3JCRCxPQUFPRSxPQUFPLEdBQUc7SUFBQztJQUFVO0NBQUs7QUFDakMsU0FBU0YsT0FBT0csS0FBSzs7SUFDakIsVUFBVUEsS0FBSztRQUNmOzs7Ozs7Ozs7S0FTQyxHQUNELFNBQVNDLFFBQVFDLE9BQU8sRUFBRUMsWUFBWTtZQUNwQyxPQUFPRCxRQUFRRCxPQUFPLENBQUMsY0FBYyxTQUFVRyxDQUFDLEVBQUVDLEtBQUs7Z0JBQ3JELE9BQU8sUUFBUUYsWUFBWSxDQUFDLENBQUNFLE1BQU0sR0FBRztZQUN4QztRQUNGO1FBQ0E7Ozs7O0tBS0MsR0FDRCxTQUFTQyxHQUFHSixPQUFPLEVBQUVDLFlBQVksRUFBRUksS0FBSztZQUN0QyxPQUFPQyxPQUFPUCxRQUFRQyxTQUFTQyxlQUFlSSxTQUFTO1FBQ3pEO1FBQ0E7Ozs7OztLQU1DLEdBQ0QsU0FBU0UsT0FBT1AsT0FBTyxFQUFFUSxTQUFTO1lBQ2hDLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJRCxXQUFXQyxJQUFLO2dCQUNsQ1QsVUFBVUEsUUFBUUQsT0FBTyxDQUFDLGFBQWE7b0JBQ3JDLE9BQU8sUUFBUUMsVUFBVTtnQkFDM0I7WUFDRjtZQUNBLE9BQU9BLFFBQVFELE9BQU8sQ0FBQyxhQUFhO1FBQ3RDLEVBQUUsOEVBQThFO1FBQ2hGLElBQUlXLGVBQWU7WUFDakIscURBQXFEO1lBQ3JEQyxNQUFNO1lBQ04sNENBQTRDO1lBQzVDQyxpQkFBaUI7WUFDakIsc0JBQXNCO1lBQ3RCLHFFQUFxRTtZQUNyRUMsWUFDRTtZQUNGLHFCQUFxQjtZQUNyQkMsT0FDRTtRQUNKLEVBQUUsV0FBVzs7UUFDYixTQUFTQyxrQkFBa0JDLEtBQUs7WUFDOUIsT0FBTyxXQUFXQSxNQUFNQyxJQUFJ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NEJBQ1ZyRSxTQUFTOzRCQUNUaUQsT0FBTzs0QkFDUEwsUUFBUTlDLE1BQU15QyxTQUFTLENBQUM1QyxNQUFNO3dCQUNoQztvQkFDRjtnQkFDRjtnQkFDQThDLFFBQVE7WUFDVjtRQUNGO1FBQ0EzQyxNQUFNeUMsU0FBUyxDQUFDUSxZQUFZLENBQUMsVUFBVSxVQUFVO1lBQy9DLHdCQUF3QjtnQkFDdEI7b0JBQ0UvQyxTQUFTSSxHQUNQLDREQUE0RG1CLE1BQU0sRUFDbEU7d0JBQUN3QztxQkFBZTtvQkFFbEJyQixZQUFZO29CQUNaQyxRQUFRO29CQUNSQyxRQUFRc0IsMEJBQTBCSCxnQkFBZ0JEO2dCQUNwRDtnQkFDQTtvQkFDRTlELFNBQVNJLEdBQUcsNENBQTRDbUIsTUFBTSxFQUFFO3dCQUM5RDBDO3FCQUNEO29CQUNEdkIsWUFBWTtvQkFDWkMsUUFBUTtvQkFDUkMsUUFBUXNCLDBCQUEwQkQsZ0JBQWdCRDtnQkFDcEQ7YUFDRDtZQUNETSxNQUFNO2dCQUNKdEUsU0FBU00sT0FBTzhCO2dCQUNoQk8sUUFBUTtZQUNWO1FBQ0Y7UUFDQTdDLE1BQU15QyxTQUFTLENBQUNnQyxNQUFNLEdBQUd6RSxNQUFNeUMsU0FBUyxDQUFDaUMsRUFBRSxHQUFHMUUsTUFBTXlDLFNBQVMsQ0FBQzVDLE1BQU07SUFDdEUsR0FBR0c7QUFDTCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVmcmFjdG9yL2xhbmcvY3NoYXJwLmpzP2ExZTciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gY3NoYXJwXG5jc2hhcnAuZGlzcGxheU5hbWUgPSAnY3NoYXJwJ1xuY3NoYXJwLmFsaWFzZXMgPSBbJ2RvdG5ldCcsICdjcyddXG5mdW5jdGlvbiBjc2hhcnAoUHJpc20pIHtcbiAgOyhmdW5jdGlvbiAoUHJpc20pIHtcbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyBhbGwgcGxhY2Vob2xkZXJzIFwiPDxuPj5cIiBvZiBnaXZlbiBwYXR0ZXJuIHdpdGggdGhlIG4tdGggcmVwbGFjZW1lbnQgKHplcm8gYmFzZWQpLlxuICAgICAqXG4gICAgICogTm90ZTogVGhpcyBpcyBhIHNpbXBsZSB0ZXh0IGJhc2VkIHJlcGxhY2VtZW50LiBCZSBjYXJlZnVsIHdoZW4gdXNpbmcgYmFja3JlZmVyZW5jZXMhXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0dGVybiB0aGUgZ2l2ZW4gcGF0dGVybi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSByZXBsYWNlbWVudHMgYSBsaXN0IG9mIHJlcGxhY2VtZW50IHdoaWNoIGNhbiBiZSBpbnNlcnRlZCBpbnRvIHRoZSBnaXZlbiBwYXR0ZXJuLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBwYXR0ZXJuIHdpdGggYWxsIHBsYWNlaG9sZGVycyByZXBsYWNlZCB3aXRoIHRoZWlyIGNvcnJlc3BvbmRpbmcgcmVwbGFjZW1lbnRzLlxuICAgICAqIEBleGFtcGxlIHJlcGxhY2UoL2E8PDA+PmEvLnNvdXJjZSwgWy9iKy8uc291cmNlXSkgPT09IC9hKD86YispYS8uc291cmNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVwbGFjZShwYXR0ZXJuLCByZXBsYWNlbWVudHMpIHtcbiAgICAgIHJldHVybiBwYXR0ZXJuLnJlcGxhY2UoLzw8KFxcZCspPj4vZywgZnVuY3Rpb24gKG0sIGluZGV4KSB7XG4gICAgICAgIHJldHVybiAnKD86JyArIHJlcGxhY2VtZW50c1sraW5kZXhdICsgJyknXG4gICAgICB9KVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0dGVyblxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHJlcGxhY2VtZW50c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbZmxhZ3NdXG4gICAgICogQHJldHVybnMge1JlZ0V4cH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZShwYXR0ZXJuLCByZXBsYWNlbWVudHMsIGZsYWdzKSB7XG4gICAgICByZXR1cm4gUmVnRXhwKHJlcGxhY2UocGF0dGVybiwgcmVwbGFjZW1lbnRzKSwgZmxhZ3MgfHwgJycpXG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXN0ZWQgcGF0dGVybiB3aGVyZSBhbGwgb2NjdXJyZW5jZXMgb2YgdGhlIHN0cmluZyBgPDxzZWxmPj5gIGFyZSByZXBsYWNlZCB3aXRoIHRoZSBwYXR0ZXJuIGl0c2VsZi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXR0ZXJuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlcHRoTG9nMlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbmVzdGVkKHBhdHRlcm4sIGRlcHRoTG9nMikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZXB0aExvZzI7IGkrKykge1xuICAgICAgICBwYXR0ZXJuID0gcGF0dGVybi5yZXBsYWNlKC88PHNlbGY+Pi9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuICcoPzonICsgcGF0dGVybiArICcpJ1xuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgcmV0dXJuIHBhdHRlcm4ucmVwbGFjZSgvPDxzZWxmPj4vZywgJ1teXFxcXHNcXFxcU10nKVxuICAgIH0gLy8gaHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvZG90bmV0L2NzaGFycC9sYW5ndWFnZS1yZWZlcmVuY2Uva2V5d29yZHMvXG4gICAgdmFyIGtleXdvcmRLaW5kcyA9IHtcbiAgICAgIC8vIGtleXdvcmRzIHdoaWNoIHJlcHJlc2VudCBhIHJldHVybiBvciB2YXJpYWJsZSB0eXBlXG4gICAgICB0eXBlOiAnYm9vbCBieXRlIGNoYXIgZGVjaW1hbCBkb3VibGUgZHluYW1pYyBmbG9hdCBpbnQgbG9uZyBvYmplY3Qgc2J5dGUgc2hvcnQgc3RyaW5nIHVpbnQgdWxvbmcgdXNob3J0IHZhciB2b2lkJyxcbiAgICAgIC8vIGtleXdvcmRzIHdoaWNoIGFyZSB1c2VkIHRvIGRlY2xhcmUgYSB0eXBlXG4gICAgICB0eXBlRGVjbGFyYXRpb246ICdjbGFzcyBlbnVtIGludGVyZmFjZSByZWNvcmQgc3RydWN0JyxcbiAgICAgIC8vIGNvbnRleHR1YWwga2V5d29yZHNcbiAgICAgIC8vIChcInZhclwiIGFuZCBcImR5bmFtaWNcIiBhcmUgbWlzc2luZyBiZWNhdXNlIHRoZXkgYXJlIHVzZWQgbGlrZSB0eXBlcylcbiAgICAgIGNvbnRleHR1YWw6XG4gICAgICAgICdhZGQgYWxpYXMgYW5kIGFzY2VuZGluZyBhc3luYyBhd2FpdCBieSBkZXNjZW5kaW5nIGZyb20oPz1cXFxccyooPzpcXFxcd3wkKSkgZ2V0IGdsb2JhbCBncm91cCBpbnRvIGluaXQoPz1cXFxccyo7KSBqb2luIGxldCBuYW1lb2Ygbm90IG5vdG51bGwgb24gb3Igb3JkZXJieSBwYXJ0aWFsIHJlbW92ZSBzZWxlY3Qgc2V0IHVubWFuYWdlZCB2YWx1ZSB3aGVuIHdoZXJlIHdpdGgoPz1cXFxccyp7KScsXG4gICAgICAvLyBhbGwgb3RoZXIga2V5d29yZHNcbiAgICAgIG90aGVyOlxuICAgICAgICAnYWJzdHJhY3QgYXMgYmFzZSBicmVhayBjYXNlIGNhdGNoIGNoZWNrZWQgY29uc3QgY29udGludWUgZGVmYXVsdCBkZWxlZ2F0ZSBkbyBlbHNlIGV2ZW50IGV4cGxpY2l0IGV4dGVybiBmaW5hbGx5IGZpeGVkIGZvciBmb3JlYWNoIGdvdG8gaWYgaW1wbGljaXQgaW4gaW50ZXJuYWwgaXMgbG9jayBuYW1lc3BhY2UgbmV3IG51bGwgb3BlcmF0b3Igb3V0IG92ZXJyaWRlIHBhcmFtcyBwcml2YXRlIHByb3RlY3RlZCBwdWJsaWMgcmVhZG9ubHkgcmVmIHJldHVybiBzZWFsZWQgc2l6ZW9mIHN0YWNrYWxsb2Mgc3RhdGljIHN3aXRjaCB0aGlzIHRocm93IHRyeSB0eXBlb2YgdW5jaGVja2VkIHVuc2FmZSB1c2luZyB2aXJ0dWFsIHZvbGF0aWxlIHdoaWxlIHlpZWxkJ1xuICAgIH0gLy8ga2V5d29yZHNcbiAgICBmdW5jdGlvbiBrZXl3b3Jkc1RvUGF0dGVybih3b3Jkcykge1xuICAgICAgcmV0dXJuICdcXFxcYig/OicgKyB3b3Jkcy50cmltKCkucmVwbGFjZSgvIC9nLCAnfCcpICsgJylcXFxcYidcbiAgICB9XG4gICAgdmFyIHR5cGVEZWNsYXJhdGlvbktleXdvcmRzID0ga2V5d29yZHNUb1BhdHRlcm4oXG4gICAgICBrZXl3b3JkS2luZHMudHlwZURlY2xhcmF0aW9uXG4gICAgKVxuICAgIHZhciBrZXl3b3JkcyA9IFJlZ0V4cChcbiAgICAgIGtleXdvcmRzVG9QYXR0ZXJuKFxuICAgICAgICBrZXl3b3JkS2luZHMudHlwZSArXG4gICAgICAgICAgJyAnICtcbiAgICAgICAgICBrZXl3b3JkS2luZHMudHlwZURlY2xhcmF0aW9uICtcbiAgICAgICAgICAnICcgK1xuICAgICAgICAgIGtleXdvcmRLaW5kcy5jb250ZXh0dWFsICtcbiAgICAgICAgICAnICcgK1xuICAgICAgICAgIGtleXdvcmRLaW5kcy5vdGhlclxuICAgICAgKVxuICAgIClcbiAgICB2YXIgbm9uVHlwZUtleXdvcmRzID0ga2V5d29yZHNUb1BhdHRlcm4oXG4gICAgICBrZXl3b3JkS2luZHMudHlwZURlY2xhcmF0aW9uICtcbiAgICAgICAgJyAnICtcbiAgICAgICAga2V5d29yZEtpbmRzLmNvbnRleHR1YWwgK1xuICAgICAgICAnICcgK1xuICAgICAgICBrZXl3b3JkS2luZHMub3RoZXJcbiAgICApXG4gICAgdmFyIG5vbkNvbnRleHR1YWxLZXl3b3JkcyA9IGtleXdvcmRzVG9QYXR0ZXJuKFxuICAgICAga2V5d29yZEtpbmRzLnR5cGUgK1xuICAgICAgICAnICcgK1xuICAgICAgICBrZXl3b3JkS2luZHMudHlwZURlY2xhcmF0aW9uICtcbiAgICAgICAgJyAnICtcbiAgICAgICAga2V5d29yZEtpbmRzLm90aGVyXG4gICAgKSAvLyB0eXBlc1xuICAgIHZhciBnZW5lcmljID0gbmVzdGVkKC88KD86W148Pjs9K1xcLSovJSZ8Xl18PDxzZWxmPj4pKj4vLnNvdXJjZSwgMikgLy8gdGhlIGlkZWEgYmVoaW5kIHRoZSBvdGhlciBmb3JiaWRkZW4gY2hhcmFjdGVycyBpcyB0byBwcmV2ZW50IGZhbHNlIHBvc2l0aXZlcy4gU2FtZSBmb3IgdHVwbGVFbGVtZW50LlxuICAgIHZhciBuZXN0ZWRSb3VuZCA9IG5lc3RlZCgvXFwoKD86W14oKV18PDxzZWxmPj4pKlxcKS8uc291cmNlLCAyKVxuICAgIHZhciBuYW1lID0gL0A/XFxiW0EtWmEtel9dXFx3KlxcYi8uc291cmNlXG4gICAgdmFyIGdlbmVyaWNOYW1lID0gcmVwbGFjZSgvPDwwPj4oPzpcXHMqPDwxPj4pPy8uc291cmNlLCBbbmFtZSwgZ2VuZXJpY10pXG4gICAgdmFyIGlkZW50aWZpZXIgPSByZXBsYWNlKC8oPyE8PDA+Pik8PDE+Pig/OlxccypcXC5cXHMqPDwxPj4pKi8uc291cmNlLCBbXG4gICAgICBub25UeXBlS2V5d29yZHMsXG4gICAgICBnZW5lcmljTmFtZVxuICAgIF0pXG4gICAgdmFyIGFycmF5ID0gL1xcW1xccyooPzosXFxzKikqXFxdLy5zb3VyY2VcbiAgICB2YXIgdHlwZUV4cHJlc3Npb25XaXRob3V0VHVwbGUgPSByZXBsYWNlKFxuICAgICAgLzw8MD4+KD86XFxzKig/OlxcP1xccyopPzw8MT4+KSooPzpcXHMqXFw/KT8vLnNvdXJjZSxcbiAgICAgIFtpZGVudGlmaWVyLCBhcnJheV1cbiAgICApXG4gICAgdmFyIHR1cGxlRWxlbWVudCA9IHJlcGxhY2UoXG4gICAgICAvW14sKCk8PltcXF07PStcXC0qLyUmfF5dfDw8MD4+fDw8MT4+fDw8Mj4+Ly5zb3VyY2UsXG4gICAgICBbZ2VuZXJpYywgbmVzdGVkUm91bmQsIGFycmF5XVxuICAgIClcbiAgICB2YXIgdHVwbGUgPSByZXBsYWNlKC9cXCg8PDA+PisoPzosPDwwPj4rKStcXCkvLnNvdXJjZSwgW3R1cGxlRWxlbWVudF0pXG4gICAgdmFyIHR5cGVFeHByZXNzaW9uID0gcmVwbGFjZShcbiAgICAgIC8oPzo8PDA+Pnw8PDE+PikoPzpcXHMqKD86XFw/XFxzKik/PDwyPj4pKig/OlxccypcXD8pPy8uc291cmNlLFxuICAgICAgW3R1cGxlLCBpZGVudGlmaWVyLCBhcnJheV1cbiAgICApXG4gICAgdmFyIHR5cGVJbnNpZGUgPSB7XG4gICAgICBrZXl3b3JkOiBrZXl3b3JkcyxcbiAgICAgIHB1bmN0dWF0aW9uOiAvWzw+KCk/LC46W1xcXV0vXG4gICAgfSAvLyBzdHJpbmdzICYgY2hhcmFjdGVyc1xuICAgIC8vIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL2RvdG5ldC9jc2hhcnAvbGFuZ3VhZ2UtcmVmZXJlbmNlL2xhbmd1YWdlLXNwZWNpZmljYXRpb24vbGV4aWNhbC1zdHJ1Y3R1cmUjY2hhcmFjdGVyLWxpdGVyYWxzXG4gICAgLy8gaHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvZG90bmV0L2NzaGFycC9sYW5ndWFnZS1yZWZlcmVuY2UvbGFuZ3VhZ2Utc3BlY2lmaWNhdGlvbi9sZXhpY2FsLXN0cnVjdHVyZSNzdHJpbmctbGl0ZXJhbHNcbiAgICB2YXIgY2hhcmFjdGVyID0gLycoPzpbXlxcclxcbidcXFxcXXxcXFxcLnxcXFxcW1V1eF1bXFxkYS1mQS1GXXsxLDh9KScvLnNvdXJjZSAvLyBzaW1wbGlmaWVkIHBhdHRlcm5cbiAgICB2YXIgcmVndWxhclN0cmluZyA9IC9cIig/OlxcXFwufFteXFxcXFwiXFxyXFxuXSkqXCIvLnNvdXJjZVxuICAgIHZhciB2ZXJiYXRpbVN0cmluZyA9IC9AXCIoPzpcIlwifFxcXFxbXFxzXFxTXXxbXlxcXFxcIl0pKlwiKD8hXCIpLy5zb3VyY2VcbiAgICBQcmlzbS5sYW5ndWFnZXMuY3NoYXJwID0gUHJpc20ubGFuZ3VhZ2VzLmV4dGVuZCgnY2xpa2UnLCB7XG4gICAgICBzdHJpbmc6IFtcbiAgICAgICAge1xuICAgICAgICAgIHBhdHRlcm46IHJlKC8oXnxbXiRcXFxcXSk8PDA+Pi8uc291cmNlLCBbdmVyYmF0aW1TdHJpbmddKSxcbiAgICAgICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgICAgIGdyZWVkeTogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgcGF0dGVybjogcmUoLyhefFteQCRcXFxcXSk8PDA+Pi8uc291cmNlLCBbcmVndWxhclN0cmluZ10pLFxuICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgICAgZ3JlZWR5OiB0cnVlXG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICAnY2xhc3MtbmFtZSc6IFtcbiAgICAgICAge1xuICAgICAgICAgIC8vIFVzaW5nIHN0YXRpY1xuICAgICAgICAgIC8vIHVzaW5nIHN0YXRpYyBTeXN0ZW0uTWF0aDtcbiAgICAgICAgICBwYXR0ZXJuOiByZSgvKFxcYnVzaW5nXFxzK3N0YXRpY1xccyspPDwwPj4oPz1cXHMqOykvLnNvdXJjZSwgW1xuICAgICAgICAgICAgaWRlbnRpZmllclxuICAgICAgICAgIF0pLFxuICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgICAgaW5zaWRlOiB0eXBlSW5zaWRlXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAvLyBVc2luZyBhbGlhcyAodHlwZSlcbiAgICAgICAgICAvLyB1c2luZyBQcm9qZWN0ID0gUEMuTXlDb21wYW55LlByb2plY3Q7XG4gICAgICAgICAgcGF0dGVybjogcmUoLyhcXGJ1c2luZ1xccys8PDA+Plxccyo9XFxzKik8PDE+Pig/PVxccyo7KS8uc291cmNlLCBbXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgdHlwZUV4cHJlc3Npb25cbiAgICAgICAgICBdKSxcbiAgICAgICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgICAgIGluc2lkZTogdHlwZUluc2lkZVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgLy8gVXNpbmcgYWxpYXMgKGFsaWFzKVxuICAgICAgICAgIC8vIHVzaW5nIFByb2plY3QgPSBQQy5NeUNvbXBhbnkuUHJvamVjdDtcbiAgICAgICAgICBwYXR0ZXJuOiByZSgvKFxcYnVzaW5nXFxzKyk8PDA+Pig/PVxccyo9KS8uc291cmNlLCBbbmFtZV0pLFxuICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIC8vIFR5cGUgZGVjbGFyYXRpb25zXG4gICAgICAgICAgLy8gY2xhc3MgRm9vPEEsIEI+XG4gICAgICAgICAgLy8gaW50ZXJmYWNlIEZvbzxvdXQgQSwgQj5cbiAgICAgICAgICBwYXR0ZXJuOiByZSgvKFxcYjw8MD4+XFxzKyk8PDE+Pi8uc291cmNlLCBbXG4gICAgICAgICAgICB0eXBlRGVjbGFyYXRpb25LZXl3b3JkcyxcbiAgICAgICAgICAgIGdlbmVyaWNOYW1lXG4gICAgICAgICAgXSksXG4gICAgICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgICAgICBpbnNpZGU6IHR5cGVJbnNpZGVcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIC8vIFNpbmdsZSBjYXRjaCBleGNlcHRpb24gZGVjbGFyYXRpb25cbiAgICAgICAgICAvLyBjYXRjaChGb28pXG4gICAgICAgICAgLy8gKHRoaW5ncyBsaWtlIGNhdGNoKEZvbyBlKSBpcyBjb3ZlcmVkIGJ5IHZhcmlhYmxlIGRlY2xhcmF0aW9uKVxuICAgICAgICAgIHBhdHRlcm46IHJlKC8oXFxiY2F0Y2hcXHMqXFwoXFxzKik8PDA+Pi8uc291cmNlLCBbaWRlbnRpZmllcl0pLFxuICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgICAgaW5zaWRlOiB0eXBlSW5zaWRlXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAvLyBOYW1lIG9mIHRoZSB0eXBlIHBhcmFtZXRlciBvZiBnZW5lcmljIGNvbnN0cmFpbnRzXG4gICAgICAgICAgLy8gd2hlcmUgRm9vIDogY2xhc3NcbiAgICAgICAgICBwYXR0ZXJuOiByZSgvKFxcYndoZXJlXFxzKyk8PDA+Pi8uc291cmNlLCBbbmFtZV0pLFxuICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIC8vIENhc3RzIGFuZCBjaGVja3MgdmlhIGFzIGFuZCBpcy5cbiAgICAgICAgICAvLyBhcyBGb288QT4sIGlzIEJhcjxCPlxuICAgICAgICAgIC8vICh0aGluZ3MgbGlrZSBpZihhIGlzIEZvbyBiKSBpcyBjb3ZlcmVkIGJ5IHZhcmlhYmxlIGRlY2xhcmF0aW9uKVxuICAgICAgICAgIHBhdHRlcm46IHJlKC8oXFxiKD86aXMoPzpcXHMrbm90KT98YXMpXFxzKyk8PDA+Pi8uc291cmNlLCBbXG4gICAgICAgICAgICB0eXBlRXhwcmVzc2lvbldpdGhvdXRUdXBsZVxuICAgICAgICAgIF0pLFxuICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgICAgaW5zaWRlOiB0eXBlSW5zaWRlXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAvLyBWYXJpYWJsZSwgZmllbGQgYW5kIHBhcmFtZXRlciBkZWNsYXJhdGlvblxuICAgICAgICAgIC8vIChGb28gYmFyLCBCYXIgYmF6LCBGb29bLCxdIGJheSwgRm9vPEJhciwgRm9vQmFyPEJhcj4+IGJheClcbiAgICAgICAgICBwYXR0ZXJuOiByZShcbiAgICAgICAgICAgIC9cXGI8PDA+Pig/PVxccysoPyE8PDE+Pnx3aXRoXFxzKlxceyk8PDI+Pig/OlxccypbPSw7OnspXFxdXXxcXHMrKD86aW58d2hlbilcXGIpKS9cbiAgICAgICAgICAgICAgLnNvdXJjZSxcbiAgICAgICAgICAgIFt0eXBlRXhwcmVzc2lvbiwgbm9uQ29udGV4dHVhbEtleXdvcmRzLCBuYW1lXVxuICAgICAgICAgICksXG4gICAgICAgICAgaW5zaWRlOiB0eXBlSW5zaWRlXG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICBrZXl3b3JkOiBrZXl3b3JkcyxcbiAgICAgIC8vIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL2RvdG5ldC9jc2hhcnAvbGFuZ3VhZ2UtcmVmZXJlbmNlL2xhbmd1YWdlLXNwZWNpZmljYXRpb24vbGV4aWNhbC1zdHJ1Y3R1cmUjbGl0ZXJhbHNcbiAgICAgIG51bWJlcjpcbiAgICAgICAgLyg/OlxcYjAoPzp4W1xcZGEtZl9dKltcXGRhLWZdfGJbMDFfXSpbMDFdKXwoPzpcXEJcXC5cXGQrKD86XytcXGQrKSp8XFxiXFxkKyg/Ol8rXFxkKykqKD86XFwuXFxkKyg/Ol8rXFxkKykqKT8pKD86ZVstK10/XFxkKyg/Ol8rXFxkKykqKT8pKD86W2RmbG11XXxsdXx1bCk/XFxiL2ksXG4gICAgICBvcGVyYXRvcjogLz4+PT98PDw9P3xbLT1dPnwoWy0rJnxdKVxcMXx+fFxcP1xcPz0/fFstKyovJSZ8XiE9PD5dPT8vLFxuICAgICAgcHVuY3R1YXRpb246IC9cXD9cXC4/fDo6fFt7fVtcXF07KCksLjpdL1xuICAgIH0pXG4gICAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnY3NoYXJwJywgJ251bWJlcicsIHtcbiAgICAgIHJhbmdlOiB7XG4gICAgICAgIHBhdHRlcm46IC9cXC5cXC4vLFxuICAgICAgICBhbGlhczogJ29wZXJhdG9yJ1xuICAgICAgfVxuICAgIH0pXG4gICAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnY3NoYXJwJywgJ3B1bmN0dWF0aW9uJywge1xuICAgICAgJ25hbWVkLXBhcmFtZXRlcic6IHtcbiAgICAgICAgcGF0dGVybjogcmUoLyhbKCxdXFxzKik8PDA+Pig/PVxccyo6KS8uc291cmNlLCBbbmFtZV0pLFxuICAgICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgICBhbGlhczogJ3B1bmN0dWF0aW9uJ1xuICAgICAgfVxuICAgIH0pXG4gICAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnY3NoYXJwJywgJ2NsYXNzLW5hbWUnLCB7XG4gICAgICBuYW1lc3BhY2U6IHtcbiAgICAgICAgLy8gbmFtZXNwYWNlIEZvby5CYXIge31cbiAgICAgICAgLy8gdXNpbmcgRm9vLkJhcjtcbiAgICAgICAgcGF0dGVybjogcmUoXG4gICAgICAgICAgLyhcXGIoPzpuYW1lc3BhY2V8dXNpbmcpXFxzKyk8PDA+Pig/OlxccypcXC5cXHMqPDwwPj4pKig/PVxccypbO3tdKS8uc291cmNlLFxuICAgICAgICAgIFtuYW1lXVxuICAgICAgICApLFxuICAgICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgICBpbnNpZGU6IHtcbiAgICAgICAgICBwdW5jdHVhdGlvbjogL1xcLi9cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgICd0eXBlLWV4cHJlc3Npb24nOiB7XG4gICAgICAgIC8vIGRlZmF1bHQoRm9vKSwgdHlwZW9mKEZvbzxCYXI+KSwgc2l6ZW9mKGludClcbiAgICAgICAgcGF0dGVybjogcmUoXG4gICAgICAgICAgLyhcXGIoPzpkZWZhdWx0fHNpemVvZnx0eXBlb2YpXFxzKlxcKFxccyooPyFcXHMpKSg/OlteKClcXHNdfFxccyg/IVxccyl8PDwwPj4pKig/PVxccypcXCkpL1xuICAgICAgICAgICAgLnNvdXJjZSxcbiAgICAgICAgICBbbmVzdGVkUm91bmRdXG4gICAgICAgICksXG4gICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgIGFsaWFzOiAnY2xhc3MtbmFtZScsXG4gICAgICAgIGluc2lkZTogdHlwZUluc2lkZVxuICAgICAgfSxcbiAgICAgICdyZXR1cm4tdHlwZSc6IHtcbiAgICAgICAgLy8gRm9vPEJhcj4gRm9yQmFyKCk7IEZvbyBJRm9vLkJhcigpID0+IDBcbiAgICAgICAgLy8gaW50IHRoaXNbaW50IGluZGV4XSA9PiAwOyBUIElSZWFkT25seUxpc3Q8VD4udGhpc1tpbnQgaW5kZXhdID0+IHRoaXNbaW5kZXhdO1xuICAgICAgICAvLyBpbnQgRm9vID0+IDA7IGludCBGb28geyBnZXQ7IHNldCB9ID0gMDtcbiAgICAgICAgcGF0dGVybjogcmUoXG4gICAgICAgICAgLzw8MD4+KD89XFxzKyg/Ojw8MT4+XFxzKig/Oj0+fFsoe118XFwuXFxzKnRoaXNcXHMqXFxbKXx0aGlzXFxzKlxcWykpLy5zb3VyY2UsXG4gICAgICAgICAgW3R5cGVFeHByZXNzaW9uLCBpZGVudGlmaWVyXVxuICAgICAgICApLFxuICAgICAgICBpbnNpZGU6IHR5cGVJbnNpZGUsXG4gICAgICAgIGFsaWFzOiAnY2xhc3MtbmFtZSdcbiAgICAgIH0sXG4gICAgICAnY29uc3RydWN0b3ItaW52b2NhdGlvbic6IHtcbiAgICAgICAgLy8gbmV3IExpc3Q8Rm9vPEJhcltdPj4geyB9XG4gICAgICAgIHBhdHRlcm46IHJlKC8oXFxibmV3XFxzKyk8PDA+Pig/PVxccypbWyh7XSkvLnNvdXJjZSwgW3R5cGVFeHByZXNzaW9uXSksXG4gICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgIGluc2lkZTogdHlwZUluc2lkZSxcbiAgICAgICAgYWxpYXM6ICdjbGFzcy1uYW1lJ1xuICAgICAgfSxcbiAgICAgIC8qJ2V4cGxpY2l0LWltcGxlbWVudGF0aW9uJzoge1xuLy8gaW50IElGb288Rm9vPi5CYXIgPT4gMDsgdm9pZCBJRm9vPEZvbzxGb28+Pi5Gb288VD4oKTtcbnBhdHRlcm46IHJlcGxhY2UoL1xcYjw8MD4+KD89XFwuPDwxPj4pLywgY2xhc3NOYW1lLCBtZXRob2RPclByb3BlcnR5RGVjbGFyYXRpb24pLFxuaW5zaWRlOiBjbGFzc05hbWVJbnNpZGUsXG5hbGlhczogJ2NsYXNzLW5hbWUnXG59LCovXG4gICAgICAnZ2VuZXJpYy1tZXRob2QnOiB7XG4gICAgICAgIC8vIGZvbzxCYXI+KClcbiAgICAgICAgcGF0dGVybjogcmUoLzw8MD4+XFxzKjw8MT4+KD89XFxzKlxcKCkvLnNvdXJjZSwgW25hbWUsIGdlbmVyaWNdKSxcbiAgICAgICAgaW5zaWRlOiB7XG4gICAgICAgICAgZnVuY3Rpb246IHJlKC9ePDwwPj4vLnNvdXJjZSwgW25hbWVdKSxcbiAgICAgICAgICBnZW5lcmljOiB7XG4gICAgICAgICAgICBwYXR0ZXJuOiBSZWdFeHAoZ2VuZXJpYyksXG4gICAgICAgICAgICBhbGlhczogJ2NsYXNzLW5hbWUnLFxuICAgICAgICAgICAgaW5zaWRlOiB0eXBlSW5zaWRlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgJ3R5cGUtbGlzdCc6IHtcbiAgICAgICAgLy8gVGhlIGxpc3Qgb2YgdHlwZXMgaW5oZXJpdGVkIG9yIG9mIGdlbmVyaWMgY29uc3RyYWludHNcbiAgICAgICAgLy8gY2xhc3MgRm9vPEY+IDogQmFyLCBJTGlzdDxGb29CYXI+XG4gICAgICAgIC8vIHdoZXJlIEYgOiBCYXIsIElMaXN0PGludD5cbiAgICAgICAgcGF0dGVybjogcmUoXG4gICAgICAgICAgL1xcYigoPzo8PDA+Plxccys8PDE+PnxyZWNvcmRcXHMrPDwxPj5cXHMqPDw1Pj58d2hlcmVcXHMrPDwyPj4pXFxzKjpcXHMqKSg/Ojw8Mz4+fDw8ND4+fDw8MT4+XFxzKjw8NT4+fDw8Nj4+KSg/OlxccyosXFxzKig/Ojw8Mz4+fDw8ND4+fDw8Nj4+KSkqKD89XFxzKig/OndoZXJlfFt7O118PT58JCkpL1xuICAgICAgICAgICAgLnNvdXJjZSxcbiAgICAgICAgICBbXG4gICAgICAgICAgICB0eXBlRGVjbGFyYXRpb25LZXl3b3JkcyxcbiAgICAgICAgICAgIGdlbmVyaWNOYW1lLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHR5cGVFeHByZXNzaW9uLFxuICAgICAgICAgICAga2V5d29yZHMuc291cmNlLFxuICAgICAgICAgICAgbmVzdGVkUm91bmQsXG4gICAgICAgICAgICAvXFxibmV3XFxzKlxcKFxccypcXCkvLnNvdXJjZVxuICAgICAgICAgIF1cbiAgICAgICAgKSxcbiAgICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgICAgaW5zaWRlOiB7XG4gICAgICAgICAgJ3JlY29yZC1hcmd1bWVudHMnOiB7XG4gICAgICAgICAgICBwYXR0ZXJuOiByZSgvKF4oPyFuZXdcXHMqXFwoKTw8MD4+XFxzKik8PDE+Pi8uc291cmNlLCBbXG4gICAgICAgICAgICAgIGdlbmVyaWNOYW1lLFxuICAgICAgICAgICAgICBuZXN0ZWRSb3VuZFxuICAgICAgICAgICAgXSksXG4gICAgICAgICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgICAgICAgaW5zaWRlOiBQcmlzbS5sYW5ndWFnZXMuY3NoYXJwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBrZXl3b3JkOiBrZXl3b3JkcyxcbiAgICAgICAgICAnY2xhc3MtbmFtZSc6IHtcbiAgICAgICAgICAgIHBhdHRlcm46IFJlZ0V4cCh0eXBlRXhwcmVzc2lvbiksXG4gICAgICAgICAgICBncmVlZHk6IHRydWUsXG4gICAgICAgICAgICBpbnNpZGU6IHR5cGVJbnNpZGVcbiAgICAgICAgICB9LFxuICAgICAgICAgIHB1bmN0dWF0aW9uOiAvWywoKV0vXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwcmVwcm9jZXNzb3I6IHtcbiAgICAgICAgcGF0dGVybjogLyheW1xcdCBdKikjLiovbSxcbiAgICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgICAgYWxpYXM6ICdwcm9wZXJ0eScsXG4gICAgICAgIGluc2lkZToge1xuICAgICAgICAgIC8vIGhpZ2hsaWdodCBwcmVwcm9jZXNzb3IgZGlyZWN0aXZlcyBhcyBrZXl3b3Jkc1xuICAgICAgICAgIGRpcmVjdGl2ZToge1xuICAgICAgICAgICAgcGF0dGVybjpcbiAgICAgICAgICAgICAgLygjKVxcYig/OmRlZmluZXxlbGlmfGVsc2V8ZW5kaWZ8ZW5kcmVnaW9ufGVycm9yfGlmfGxpbmV8bnVsbGFibGV8cHJhZ21hfHJlZ2lvbnx1bmRlZnx3YXJuaW5nKVxcYi8sXG4gICAgICAgICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgICAgICAgYWxpYXM6ICdrZXl3b3JkJ1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pIC8vIGF0dHJpYnV0ZXNcbiAgICB2YXIgcmVndWxhclN0cmluZ09yQ2hhcmFjdGVyID0gcmVndWxhclN0cmluZyArICd8JyArIGNoYXJhY3RlclxuICAgIHZhciByZWd1bGFyU3RyaW5nQ2hhcmFjdGVyT3JDb21tZW50ID0gcmVwbGFjZShcbiAgICAgIC9cXC8oPyFbKi9dKXxcXC9cXC9bXlxcclxcbl0qW1xcclxcbl18XFwvXFwqKD86W14qXXxcXCooPyFcXC8pKSpcXCpcXC98PDwwPj4vLnNvdXJjZSxcbiAgICAgIFtyZWd1bGFyU3RyaW5nT3JDaGFyYWN0ZXJdXG4gICAgKVxuICAgIHZhciByb3VuZEV4cHJlc3Npb24gPSBuZXN0ZWQoXG4gICAgICByZXBsYWNlKC9bXlwiJy8oKV18PDwwPj58XFwoPDxzZWxmPj4qXFwpLy5zb3VyY2UsIFtcbiAgICAgICAgcmVndWxhclN0cmluZ0NoYXJhY3Rlck9yQ29tbWVudFxuICAgICAgXSksXG4gICAgICAyXG4gICAgKSAvLyBodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9lbi11cy9kb3RuZXQvY3NoYXJwL3Byb2dyYW1taW5nLWd1aWRlL2NvbmNlcHRzL2F0dHJpYnV0ZXMvI2F0dHJpYnV0ZS10YXJnZXRzXG4gICAgdmFyIGF0dHJUYXJnZXQgPVxuICAgICAgL1xcYig/OmFzc2VtYmx5fGV2ZW50fGZpZWxkfG1ldGhvZHxtb2R1bGV8cGFyYW18cHJvcGVydHl8cmV0dXJufHR5cGUpXFxiL1xuICAgICAgICAuc291cmNlXG4gICAgdmFyIGF0dHIgPSByZXBsYWNlKC88PDA+Pig/OlxccypcXCg8PDE+PipcXCkpPy8uc291cmNlLCBbXG4gICAgICBpZGVudGlmaWVyLFxuICAgICAgcm91bmRFeHByZXNzaW9uXG4gICAgXSlcbiAgICBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdjc2hhcnAnLCAnY2xhc3MtbmFtZScsIHtcbiAgICAgIGF0dHJpYnV0ZToge1xuICAgICAgICAvLyBBdHRyaWJ1dGVzXG4gICAgICAgIC8vIFtGb29dLCBbRm9vKDEpLCBCYXIoMiwgUHJvcCA9IFwiZm9vXCIpXSwgW3JldHVybjogRm9vKDEpLCBCYXIoMildLCBbYXNzZW1ibHk6IEZvbyhCYXIpXVxuICAgICAgICBwYXR0ZXJuOiByZShcbiAgICAgICAgICAvKCg/Ol58W15cXHNcXHc+KT9dKVxccypcXFtcXHMqKSg/Ojw8MD4+XFxzKjpcXHMqKT88PDE+Pig/OlxccyosXFxzKjw8MT4+KSooPz1cXHMqXFxdKS9cbiAgICAgICAgICAgIC5zb3VyY2UsXG4gICAgICAgICAgW2F0dHJUYXJnZXQsIGF0dHJdXG4gICAgICAgICksXG4gICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgICAgaW5zaWRlOiB7XG4gICAgICAgICAgdGFyZ2V0OiB7XG4gICAgICAgICAgICBwYXR0ZXJuOiByZSgvXjw8MD4+KD89XFxzKjopLy5zb3VyY2UsIFthdHRyVGFyZ2V0XSksXG4gICAgICAgICAgICBhbGlhczogJ2tleXdvcmQnXG4gICAgICAgICAgfSxcbiAgICAgICAgICAnYXR0cmlidXRlLWFyZ3VtZW50cyc6IHtcbiAgICAgICAgICAgIHBhdHRlcm46IHJlKC9cXCg8PDA+PipcXCkvLnNvdXJjZSwgW3JvdW5kRXhwcmVzc2lvbl0pLFxuICAgICAgICAgICAgaW5zaWRlOiBQcmlzbS5sYW5ndWFnZXMuY3NoYXJwXG4gICAgICAgICAgfSxcbiAgICAgICAgICAnY2xhc3MtbmFtZSc6IHtcbiAgICAgICAgICAgIHBhdHRlcm46IFJlZ0V4cChpZGVudGlmaWVyKSxcbiAgICAgICAgICAgIGluc2lkZToge1xuICAgICAgICAgICAgICBwdW5jdHVhdGlvbjogL1xcLi9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHB1bmN0dWF0aW9uOiAvWzosXS9cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pIC8vIHN0cmluZyBpbnRlcnBvbGF0aW9uXG4gICAgdmFyIGZvcm1hdFN0cmluZyA9IC86W159XFxyXFxuXSsvLnNvdXJjZSAvLyBtdWx0aSBsaW5lXG4gICAgdmFyIG1JbnRlcnBvbGF0aW9uUm91bmQgPSBuZXN0ZWQoXG4gICAgICByZXBsYWNlKC9bXlwiJy8oKV18PDwwPj58XFwoPDxzZWxmPj4qXFwpLy5zb3VyY2UsIFtcbiAgICAgICAgcmVndWxhclN0cmluZ0NoYXJhY3Rlck9yQ29tbWVudFxuICAgICAgXSksXG4gICAgICAyXG4gICAgKVxuICAgIHZhciBtSW50ZXJwb2xhdGlvbiA9IHJlcGxhY2UoL1xceyg/IVxceykoPzooPyFbfTpdKTw8MD4+KSo8PDE+Pj9cXH0vLnNvdXJjZSwgW1xuICAgICAgbUludGVycG9sYXRpb25Sb3VuZCxcbiAgICAgIGZvcm1hdFN0cmluZ1xuICAgIF0pIC8vIHNpbmdsZSBsaW5lXG4gICAgdmFyIHNJbnRlcnBvbGF0aW9uUm91bmQgPSBuZXN0ZWQoXG4gICAgICByZXBsYWNlKFxuICAgICAgICAvW15cIicvKCldfFxcLyg/IVxcKil8XFwvXFwqKD86W14qXXxcXCooPyFcXC8pKSpcXCpcXC98PDwwPj58XFwoPDxzZWxmPj4qXFwpL1xuICAgICAgICAgIC5zb3VyY2UsXG4gICAgICAgIFtyZWd1bGFyU3RyaW5nT3JDaGFyYWN0ZXJdXG4gICAgICApLFxuICAgICAgMlxuICAgIClcbiAgICB2YXIgc0ludGVycG9sYXRpb24gPSByZXBsYWNlKC9cXHsoPyFcXHspKD86KD8hW306XSk8PDA+PikqPDwxPj4/XFx9Ly5zb3VyY2UsIFtcbiAgICAgIHNJbnRlcnBvbGF0aW9uUm91bmQsXG4gICAgICBmb3JtYXRTdHJpbmdcbiAgICBdKVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUludGVycG9sYXRpb25JbnNpZGUoaW50ZXJwb2xhdGlvbiwgaW50ZXJwb2xhdGlvblJvdW5kKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbnRlcnBvbGF0aW9uOiB7XG4gICAgICAgICAgcGF0dGVybjogcmUoLygoPzpefFtee10pKD86XFx7XFx7KSopPDwwPj4vLnNvdXJjZSwgW2ludGVycG9sYXRpb25dKSxcbiAgICAgICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgICAgIGluc2lkZToge1xuICAgICAgICAgICAgJ2Zvcm1hdC1zdHJpbmcnOiB7XG4gICAgICAgICAgICAgIHBhdHRlcm46IHJlKC8oXlxceyg/Oig/IVt9Ol0pPDwwPj4pKik8PDE+Pig/PVxcfSQpLy5zb3VyY2UsIFtcbiAgICAgICAgICAgICAgICBpbnRlcnBvbGF0aW9uUm91bmQsXG4gICAgICAgICAgICAgICAgZm9ybWF0U3RyaW5nXG4gICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgICAgICAgICBpbnNpZGU6IHtcbiAgICAgICAgICAgICAgICBwdW5jdHVhdGlvbjogL146L1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHVuY3R1YXRpb246IC9eXFx7fFxcfSQvLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgICBwYXR0ZXJuOiAvW1xcc1xcU10rLyxcbiAgICAgICAgICAgICAgYWxpYXM6ICdsYW5ndWFnZS1jc2hhcnAnLFxuICAgICAgICAgICAgICBpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5jc2hhcnBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHN0cmluZzogL1tcXHNcXFNdKy9cbiAgICAgIH1cbiAgICB9XG4gICAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnY3NoYXJwJywgJ3N0cmluZycsIHtcbiAgICAgICdpbnRlcnBvbGF0aW9uLXN0cmluZyc6IFtcbiAgICAgICAge1xuICAgICAgICAgIHBhdHRlcm46IHJlKFxuICAgICAgICAgICAgLyhefFteXFxcXF0pKD86XFwkQHxAXFwkKVwiKD86XCJcInxcXFxcW1xcc1xcU118XFx7XFx7fDw8MD4+fFteXFxcXHtcIl0pKlwiLy5zb3VyY2UsXG4gICAgICAgICAgICBbbUludGVycG9sYXRpb25dXG4gICAgICAgICAgKSxcbiAgICAgICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgICAgICBpbnNpZGU6IGNyZWF0ZUludGVycG9sYXRpb25JbnNpZGUobUludGVycG9sYXRpb24sIG1JbnRlcnBvbGF0aW9uUm91bmQpXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBwYXR0ZXJuOiByZSgvKF58W15AXFxcXF0pXFwkXCIoPzpcXFxcLnxcXHtcXHt8PDwwPj58W15cXFxcXCJ7XSkqXCIvLnNvdXJjZSwgW1xuICAgICAgICAgICAgc0ludGVycG9sYXRpb25cbiAgICAgICAgICBdKSxcbiAgICAgICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgICAgICBpbnNpZGU6IGNyZWF0ZUludGVycG9sYXRpb25JbnNpZGUoc0ludGVycG9sYXRpb24sIHNJbnRlcnBvbGF0aW9uUm91bmQpXG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICBjaGFyOiB7XG4gICAgICAgIHBhdHRlcm46IFJlZ0V4cChjaGFyYWN0ZXIpLFxuICAgICAgICBncmVlZHk6IHRydWVcbiAgICAgIH1cbiAgICB9KVxuICAgIFByaXNtLmxhbmd1YWdlcy5kb3RuZXQgPSBQcmlzbS5sYW5ndWFnZXMuY3MgPSBQcmlzbS5sYW5ndWFnZXMuY3NoYXJwXG4gIH0pKFByaXNtKVxufVxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJjc2hhcnAiLCJkaXNwbGF5TmFtZSIsImFsaWFzZXMiLCJQcmlzbSIsInJlcGxhY2UiLCJwYXR0ZXJuIiwicmVwbGFjZW1lbnRzIiwibSIsImluZGV4IiwicmUiLCJmbGFncyIsIlJlZ0V4cCIsIm5lc3RlZCIsImRlcHRoTG9nMiIsImkiLCJrZXl3b3JkS2luZHMiLCJ0eXBlIiwidHlwZURlY2xhcmF0aW9uIiwiY29udGV4dHVhbCIsIm90aGVyIiwia2V5d29yZHNUb1BhdHRlcm4iLCJ3b3JkcyIsInRyaW0iLCJ0eXBlRGVjbGFyYXRpb25LZXl3b3JkcyIsImtleXdvcmRzIiwibm9uVHlwZUtleXdvcmRzIiwibm9uQ29udGV4dHVhbEtleXdvcmRzIiwiZ2VuZXJpYyIsInNvdXJjZSIsIm5lc3RlZFJvdW5kIiwibmFtZSIsImdlbmVyaWNOYW1lIiwiaWRlbnRpZmllciIsImFycmF5IiwidHlwZUV4cHJlc3Npb25XaXRob3V0VHVwbGUiLCJ0dXBsZUVsZW1lbnQiLCJ0dXBsZSIsInR5cGVFeHByZXNzaW9uIiwidHlwZUluc2lkZSIsImtleXdvcmQiLCJwdW5jdHVhdGlvbiIsImNoYXJhY3RlciIsInJlZ3VsYXJTdHJpbmciLCJ2ZXJiYXRpbVN0cmluZyIsImxhbmd1YWdlcyIsImV4dGVuZCIsInN0cmluZyIsImxvb2tiZWhpbmQiLCJncmVlZHkiLCJpbnNpZGUiLCJudW1iZXIiLCJvcGVyYXRvciIsImluc2VydEJlZm9yZSIsInJhbmdlIiwiYWxpYXMiLCJuYW1lc3BhY2UiLCJmdW5jdGlvbiIsInByZXByb2Nlc3NvciIsImRpcmVjdGl2ZSIsInJlZ3VsYXJTdHJpbmdPckNoYXJhY3RlciIsInJlZ3VsYXJTdHJpbmdDaGFyYWN0ZXJPckNvbW1lbnQiLCJyb3VuZEV4cHJlc3Npb24iLCJhdHRyVGFyZ2V0IiwiYXR0ciIsImF0dHJpYnV0ZSIsInRhcmdldCIsImZvcm1hdFN0cmluZyIsIm1JbnRlcnBvbGF0aW9uUm91bmQiLCJtSW50ZXJwb2xhdGlvbiIsInNJbnRlcnBvbGF0aW9uUm91bmQiLCJzSW50ZXJwb2xhdGlvbiIsImNyZWF0ZUludGVycG9sYXRpb25JbnNpZGUiLCJpbnRlcnBvbGF0aW9uIiwiaW50ZXJwb2xhdGlvblJvdW5kIiwiZXhwcmVzc2lvbiIsImNoYXIiLCJkb3RuZXQiLCJjcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/refractor/lang/csharp.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/refractor/lang/cshtml.js":
/*!***********************************************!*\
  !*** ./node_modules/refractor/lang/cshtml.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\nvar refractorCsharp = __webpack_require__(/*! ./csharp.js */ \"(app-pages-browser)/./node_modules/refractor/lang/csharp.js\");\nmodule.exports = cshtml;\ncshtml.displayName = \"cshtml\";\ncshtml.aliases = [\n    \"razor\"\n];\nfunction cshtml(Prism) {\n    Prism.register(refractorCsharp);\n    (function(Prism) {\n        var commentLike = /\\/(?![/*])|\\/\\/.*[\\r\\n]|\\/\\*[^*]*(?:\\*(?!\\/)[^*]*)*\\*\\//.source;\n        var stringLike = /@(?!\")|\"(?:[^\\r\\n\\\\\"]|\\\\.)*\"|@\"(?:[^\\\\\"]|\"\"|\\\\[\\s\\S])*\"(?!\")/.source + \"|\" + /'(?:(?:[^\\r\\n'\\\\]|\\\\.|\\\\[Uux][\\da-fA-F]{1,8})'|(?=[^\\\\](?!')))/.source;\n        /**\n     * Creates a nested pattern where all occurrences of the string `<<self>>` are replaced with the pattern itself.\n     *\n     * @param {string} pattern\n     * @param {number} depthLog2\n     * @returns {string}\n     */ function nested(pattern, depthLog2) {\n            for(var i = 0; i < depthLog2; i++){\n                pattern = pattern.replace(/<self>/g, function() {\n                    return \"(?:\" + pattern + \")\";\n                });\n            }\n            return pattern.replace(/<self>/g, \"[^\\\\s\\\\S]\").replace(/<str>/g, \"(?:\" + stringLike + \")\").replace(/<comment>/g, \"(?:\" + commentLike + \")\");\n        }\n        var round = nested(/\\((?:[^()'\"@/]|<str>|<comment>|<self>)*\\)/.source, 2);\n        var square = nested(/\\[(?:[^\\[\\]'\"@/]|<str>|<comment>|<self>)*\\]/.source, 2);\n        var curly = nested(/\\{(?:[^{}'\"@/]|<str>|<comment>|<self>)*\\}/.source, 2);\n        var angle = nested(/<(?:[^<>'\"@/]|<str>|<comment>|<self>)*>/.source, 2) // Note about the above bracket patterns:\n        ;\n        // They all ignore HTML expressions that might be in the C# code. This is a problem because HTML (like strings and\n        // comments) is parsed differently. This is a huge problem because HTML might contain brackets and quotes which\n        // messes up the bracket and string counting implemented by the above patterns.\n        //\n        // This problem is not fixable because 1) HTML expression are highly context sensitive and very difficult to detect\n        // and 2) they require one capturing group at every nested level. See the `tagRegion` pattern to admire the\n        // complexity of an HTML expression.\n        //\n        // To somewhat alleviate the problem a bit, the patterns for characters (e.g. 'a') is very permissive, it also\n        // allows invalid characters to support HTML expressions like this: <p>That's it!</p>.\n        var tagAttrs = /(?:\\s(?:\\s*[^\\s>\\/=]+(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))|(?=[\\s/>])))+)?/.source;\n        var tagContent = /(?!\\d)[^\\s>\\/=$<%]+/.source + tagAttrs + /\\s*\\/?>/.source;\n        var tagRegion = /\\B@?/.source + \"(?:\" + /<([a-zA-Z][\\w:]*)/.source + tagAttrs + /\\s*>/.source + \"(?:\" + (/[^<]/.source + \"|\" + // all tags that are not the start tag\n        // eslint-disable-next-line regexp/strict\n        /<\\/?(?!\\1\\b)/.source + tagContent + \"|\" + // nested start tag\n        nested(// eslint-disable-next-line regexp/strict\n        /<\\1/.source + tagAttrs + /\\s*>/.source + \"(?:\" + (/[^<]/.source + \"|\" + // all tags that are not the start tag\n        // eslint-disable-next-line regexp/strict\n        /<\\/?(?!\\1\\b)/.source + tagContent + \"|\" + \"<self>\") + \")*\" + // eslint-disable-next-line regexp/strict\n        /<\\/\\1\\s*>/.source, 2)) + \")*\" + // eslint-disable-next-line regexp/strict\n        /<\\/\\1\\s*>/.source + \"|\" + /</.source + tagContent + \")\" // Now for the actual language definition(s):\n        ;\n        //\n        // Razor as a language has 2 parts:\n        //  1) CSHTML: A markup-like language that has been extended with inline C# code expressions and blocks.\n        //  2) C#+HTML: A variant of C# that can contain CSHTML tags as expressions.\n        //\n        // In the below code, both CSHTML and C#+HTML will be create as separate language definitions that reference each\n        // other. However, only CSHTML will be exported via `Prism.languages`.\n        Prism.languages.cshtml = Prism.languages.extend(\"markup\", {});\n        var csharpWithHtml = Prism.languages.insertBefore(\"csharp\", \"string\", {\n            html: {\n                pattern: RegExp(tagRegion),\n                greedy: true,\n                inside: Prism.languages.cshtml\n            }\n        }, {\n            csharp: Prism.languages.extend(\"csharp\", {})\n        });\n        var cs = {\n            pattern: /\\S[\\s\\S]*/,\n            alias: \"language-csharp\",\n            inside: csharpWithHtml\n        };\n        Prism.languages.insertBefore(\"cshtml\", \"prolog\", {\n            \"razor-comment\": {\n                pattern: /@\\*[\\s\\S]*?\\*@/,\n                greedy: true,\n                alias: \"comment\"\n            },\n            block: {\n                pattern: RegExp(/(^|[^@])@/.source + \"(?:\" + [\n                    // @{ ... }\n                    curly,\n                    /(?:code|functions)\\s*/.source + curly,\n                    /(?:for|foreach|lock|switch|using|while)\\s*/.source + round + /\\s*/.source + curly,\n                    /do\\s*/.source + curly + /\\s*while\\s*/.source + round + /(?:\\s*;)?/.source,\n                    /try\\s*/.source + curly + /\\s*catch\\s*/.source + round + /\\s*/.source + curly + /\\s*finally\\s*/.source + curly,\n                    /if\\s*/.source + round + /\\s*/.source + curly + \"(?:\" + /\\s*else/.source + \"(?:\" + /\\s+if\\s*/.source + round + \")?\" + /\\s*/.source + curly + \")*\"\n                ].join(\"|\") + \")\"),\n                lookbehind: true,\n                greedy: true,\n                inside: {\n                    keyword: /^@\\w*/,\n                    csharp: cs\n                }\n            },\n            directive: {\n                pattern: /^([ \\t]*)@(?:addTagHelper|attribute|implements|inherits|inject|layout|model|namespace|page|preservewhitespace|removeTagHelper|section|tagHelperPrefix|using)(?=\\s).*/m,\n                lookbehind: true,\n                greedy: true,\n                inside: {\n                    keyword: /^@\\w+/,\n                    csharp: cs\n                }\n            },\n            value: {\n                pattern: RegExp(/(^|[^@])@/.source + /(?:await\\b\\s*)?/.source + \"(?:\" + /\\w+\\b/.source + \"|\" + round + \")\" + \"(?:\" + /[?!]?\\.\\w+\\b/.source + \"|\" + round + \"|\" + square + \"|\" + angle + round + \")*\"),\n                lookbehind: true,\n                greedy: true,\n                alias: \"variable\",\n                inside: {\n                    keyword: /^@/,\n                    csharp: cs\n                }\n            },\n            \"delegate-operator\": {\n                pattern: /(^|[^@])@(?=<)/,\n                lookbehind: true,\n                alias: \"operator\"\n            }\n        });\n        Prism.languages.razor = Prism.languages.cshtml;\n    })(Prism);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWZyYWN0b3IvbGFuZy9jc2h0bWwuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxJQUFJQSxrQkFBa0JDLG1CQUFPQSxDQUFDO0FBQzlCQyxPQUFPQyxPQUFPLEdBQUdDO0FBQ2pCQSxPQUFPQyxXQUFXLEdBQUc7QUFDckJELE9BQU9FLE9BQU8sR0FBRztJQUFDO0NBQVE7QUFDMUIsU0FBU0YsT0FBT0csS0FBSztJQUNuQkEsTUFBTUMsUUFBUSxDQUFDUjtJQUliLFVBQVVPLEtBQUs7UUFDZixJQUFJRSxjQUFjLDBEQUNmQyxNQUFNO1FBQ1QsSUFBSUMsYUFDRiwrREFBK0RELE1BQU0sR0FDckUsTUFDQSxpRUFBaUVBLE1BQU07UUFDekU7Ozs7OztLQU1DLEdBQ0QsU0FBU0UsT0FBT0MsT0FBTyxFQUFFQyxTQUFTO1lBQ2hDLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJRCxXQUFXQyxJQUFLO2dCQUNsQ0YsVUFBVUEsUUFBUUcsT0FBTyxDQUFDLFdBQVc7b0JBQ25DLE9BQU8sUUFBUUgsVUFBVTtnQkFDM0I7WUFDRjtZQUNBLE9BQU9BLFFBQ0pHLE9BQU8sQ0FBQyxXQUFXLGFBQ25CQSxPQUFPLENBQUMsVUFBVSxRQUFRTCxhQUFhLEtBQ3ZDSyxPQUFPLENBQUMsY0FBYyxRQUFRUCxjQUFjO1FBQ2pEO1FBQ0EsSUFBSVEsUUFBUUwsT0FBTyw0Q0FBNENGLE1BQU0sRUFBRTtRQUN2RSxJQUFJUSxTQUFTTixPQUFPLDhDQUE4Q0YsTUFBTSxFQUFFO1FBQzFFLElBQUlTLFFBQVFQLE9BQU8sNENBQTRDRixNQUFNLEVBQUU7UUFDdkUsSUFBSVUsUUFBUVIsT0FBTywwQ0FBMENGLE1BQU0sRUFBRSxHQUFHLHlDQUF5Qzs7UUFDakgsa0hBQWtIO1FBQ2xILCtHQUErRztRQUMvRywrRUFBK0U7UUFDL0UsRUFBRTtRQUNGLG1IQUFtSDtRQUNuSCwyR0FBMkc7UUFDM0csb0NBQW9DO1FBQ3BDLEVBQUU7UUFD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TUFDQSxRQUNBLGVBQWVQLE1BQU0sR0FDckIsTUFDQU8sUUFDQSxNQUNBQyxTQUNBLE1BQ0FFLFFBQ0FILFFBQ0E7Z0JBRUpvQixZQUFZO2dCQUNaUCxRQUFRO2dCQUNSSSxPQUFPO2dCQUNQSCxRQUFRO29CQUNOTyxTQUFTO29CQUNUTixRQUFRQztnQkFDVjtZQUNGO1lBQ0EscUJBQXFCO2dCQUNuQnBCLFNBQVM7Z0JBQ1R3QixZQUFZO2dCQUNaSCxPQUFPO1lBQ1Q7UUFDRjtRQUNBM0IsTUFBTWlCLFNBQVMsQ0FBQ2lCLEtBQUssR0FBR2xDLE1BQU1pQixTQUFTLENBQUNwQixNQUFNO0lBQ2hELEdBQUdHO0FBQ0wiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlZnJhY3Rvci9sYW5nL2NzaHRtbC5qcz84ZWVmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xudmFyIHJlZnJhY3RvckNzaGFycCA9IHJlcXVpcmUoJy4vY3NoYXJwLmpzJylcbm1vZHVsZS5leHBvcnRzID0gY3NodG1sXG5jc2h0bWwuZGlzcGxheU5hbWUgPSAnY3NodG1sJ1xuY3NodG1sLmFsaWFzZXMgPSBbJ3Jhem9yJ11cbmZ1bmN0aW9uIGNzaHRtbChQcmlzbSkge1xuICBQcmlzbS5yZWdpc3RlcihyZWZyYWN0b3JDc2hhcnApXG4gIC8vIERvY3M6XG4gIC8vIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL2FzcG5ldC9jb3JlL3Jhem9yLXBhZ2VzLz92aWV3PWFzcG5ldGNvcmUtNS4wJnRhYnM9dmlzdWFsLXN0dWRpb1xuICAvLyBodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9lbi11cy9hc3BuZXQvY29yZS9tdmMvdmlld3MvcmF6b3I/dmlldz1hc3BuZXRjb3JlLTUuMFxuICA7KGZ1bmN0aW9uIChQcmlzbSkge1xuICAgIHZhciBjb21tZW50TGlrZSA9IC9cXC8oPyFbLypdKXxcXC9cXC8uKltcXHJcXG5dfFxcL1xcKlteKl0qKD86XFwqKD8hXFwvKVteKl0qKSpcXCpcXC8vXG4gICAgICAuc291cmNlXG4gICAgdmFyIHN0cmluZ0xpa2UgPVxuICAgICAgL0AoPyFcIil8XCIoPzpbXlxcclxcblxcXFxcIl18XFxcXC4pKlwifEBcIig/OlteXFxcXFwiXXxcIlwifFxcXFxbXFxzXFxTXSkqXCIoPyFcIikvLnNvdXJjZSArXG4gICAgICAnfCcgK1xuICAgICAgLycoPzooPzpbXlxcclxcbidcXFxcXXxcXFxcLnxcXFxcW1V1eF1bXFxkYS1mQS1GXXsxLDh9KSd8KD89W15cXFxcXSg/IScpKSkvLnNvdXJjZVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXN0ZWQgcGF0dGVybiB3aGVyZSBhbGwgb2NjdXJyZW5jZXMgb2YgdGhlIHN0cmluZyBgPDxzZWxmPj5gIGFyZSByZXBsYWNlZCB3aXRoIHRoZSBwYXR0ZXJuIGl0c2VsZi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXR0ZXJuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlcHRoTG9nMlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbmVzdGVkKHBhdHRlcm4sIGRlcHRoTG9nMikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZXB0aExvZzI7IGkrKykge1xuICAgICAgICBwYXR0ZXJuID0gcGF0dGVybi5yZXBsYWNlKC88c2VsZj4vZywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiAnKD86JyArIHBhdHRlcm4gKyAnKSdcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXR0ZXJuXG4gICAgICAgIC5yZXBsYWNlKC88c2VsZj4vZywgJ1teXFxcXHNcXFxcU10nKVxuICAgICAgICAucmVwbGFjZSgvPHN0cj4vZywgJyg/OicgKyBzdHJpbmdMaWtlICsgJyknKVxuICAgICAgICAucmVwbGFjZSgvPGNvbW1lbnQ+L2csICcoPzonICsgY29tbWVudExpa2UgKyAnKScpXG4gICAgfVxuICAgIHZhciByb3VuZCA9IG5lc3RlZCgvXFwoKD86W14oKSdcIkAvXXw8c3RyPnw8Y29tbWVudD58PHNlbGY+KSpcXCkvLnNvdXJjZSwgMilcbiAgICB2YXIgc3F1YXJlID0gbmVzdGVkKC9cXFsoPzpbXlxcW1xcXSdcIkAvXXw8c3RyPnw8Y29tbWVudD58PHNlbGY+KSpcXF0vLnNvdXJjZSwgMilcbiAgICB2YXIgY3VybHkgPSBuZXN0ZWQoL1xceyg/Oltee30nXCJAL118PHN0cj58PGNvbW1lbnQ+fDxzZWxmPikqXFx9Ly5zb3VyY2UsIDIpXG4gICAgdmFyIGFuZ2xlID0gbmVzdGVkKC88KD86W148PidcIkAvXXw8c3RyPnw8Y29tbWVudD58PHNlbGY+KSo+Ly5zb3VyY2UsIDIpIC8vIE5vdGUgYWJvdXQgdGhlIGFib3ZlIGJyYWNrZXQgcGF0dGVybnM6XG4gICAgLy8gVGhleSBhbGwgaWdub3JlIEhUTUwgZXhwcmVzc2lvbnMgdGhhdCBtaWdodCBiZSBpbiB0aGUgQyMgY29kZS4gVGhpcyBpcyBhIHByb2JsZW0gYmVjYXVzZSBIVE1MIChsaWtlIHN0cmluZ3MgYW5kXG4gICAgLy8gY29tbWVudHMpIGlzIHBhcnNlZCBkaWZmZXJlbnRseS4gVGhpcyBpcyBhIGh1Z2UgcHJvYmxlbSBiZWNhdXNlIEhUTUwgbWlnaHQgY29udGFpbiBicmFja2V0cyBhbmQgcXVvdGVzIHdoaWNoXG4gICAgLy8gbWVzc2VzIHVwIHRoZSBicmFja2V0IGFuZCBzdHJpbmcgY291bnRpbmcgaW1wbGVtZW50ZWQgYnkgdGhlIGFib3ZlIHBhdHRlcm5zLlxuICAgIC8vXG4gICAgLy8gVGhpcyBwcm9ibGVtIGlzIG5vdCBmaXhhYmxlIGJlY2F1c2UgMSkgSFRNTCBleHByZXNzaW9uIGFyZSBoaWdobHkgY29udGV4dCBzZW5zaXRpdmUgYW5kIHZlcnkgZGlmZmljdWx0IHRvIGRldGVjdFxuICAgIC8vIGFuZCAyKSB0aGV5IHJlcXVpcmUgb25lIGNhcHR1cmluZyBncm91cCBhdCBldmVyeSBuZXN0ZWQgbGV2ZWwuIFNlZSB0aGUgYHRhZ1JlZ2lvbmAgcGF0dGVybiB0byBhZG1pcmUgdGhlXG4gICAgLy8gY29tcGxleGl0eSBvZiBhbiBIVE1MIGV4cHJlc3Npb24uXG4gICAgLy9cbiAgICAvLyBUbyBzb21ld2hhdCBhbGxldmlhdGUgdGhlIHByb2JsZW0gYSBiaXQsIHRoZSBwYXR0ZXJucyBmb3IgY2hhcmFjdGVycyAoZS5nLiAnYScpIGlzIHZlcnkgcGVybWlzc2l2ZSwgaXQgYWxzb1xuICAgIC8vIGFsbG93cyBpbnZhbGlkIGNoYXJhY3RlcnMgdG8gc3VwcG9ydCBIVE1MIGV4cHJlc3Npb25zIGxpa2UgdGhpczogPHA+VGhhdCdzIGl0ITwvcD4uXG4gICAgdmFyIHRhZ0F0dHJzID1cbiAgICAgIC8oPzpcXHMoPzpcXHMqW15cXHM+XFwvPV0rKD86XFxzKj1cXHMqKD86XCJbXlwiXSpcInwnW14nXSonfFteXFxzJ1wiPj1dKyg/PVtcXHM+XSkpfCg/PVtcXHMvPl0pKSkrKT8vXG4gICAgICAgIC5zb3VyY2VcbiAgICB2YXIgdGFnQ29udGVudCA9IC8oPyFcXGQpW15cXHM+XFwvPSQ8JV0rLy5zb3VyY2UgKyB0YWdBdHRycyArIC9cXHMqXFwvPz4vLnNvdXJjZVxuICAgIHZhciB0YWdSZWdpb24gPVxuICAgICAgL1xcQkA/Ly5zb3VyY2UgK1xuICAgICAgJyg/OicgK1xuICAgICAgLzwoW2EtekEtWl1bXFx3Ol0qKS8uc291cmNlICtcbiAgICAgIHRhZ0F0dHJzICtcbiAgICAgIC9cXHMqPi8uc291cmNlICtcbiAgICAgICcoPzonICtcbiAgICAgICgvW148XS8uc291cmNlICtcbiAgICAgICAgJ3wnICsgLy8gYWxsIHRhZ3MgdGhhdCBhcmUgbm90IHRoZSBzdGFydCB0YWdcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlZ2V4cC9zdHJpY3RcbiAgICAgICAgLzxcXC8/KD8hXFwxXFxiKS8uc291cmNlICtcbiAgICAgICAgdGFnQ29udGVudCArXG4gICAgICAgICd8JyArIC8vIG5lc3RlZCBzdGFydCB0YWdcbiAgICAgICAgbmVzdGVkKFxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWdleHAvc3RyaWN0XG4gICAgICAgICAgLzxcXDEvLnNvdXJjZSArXG4gICAgICAgICAgICB0YWdBdHRycyArXG4gICAgICAgICAgICAvXFxzKj4vLnNvdXJjZSArXG4gICAgICAgICAgICAnKD86JyArXG4gICAgICAgICAgICAoL1tePF0vLnNvdXJjZSArXG4gICAgICAgICAgICAgICd8JyArIC8vIGFsbCB0YWdzIHRoYXQgYXJlIG5vdCB0aGUgc3RhcnQgdGFnXG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWdleHAvc3RyaWN0XG4gICAgICAgICAgICAgIC88XFwvPyg/IVxcMVxcYikvLnNvdXJjZSArXG4gICAgICAgICAgICAgIHRhZ0NvbnRlbnQgK1xuICAgICAgICAgICAgICAnfCcgK1xuICAgICAgICAgICAgICAnPHNlbGY+JykgK1xuICAgICAgICAgICAgJykqJyArIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWdleHAvc3RyaWN0XG4gICAgICAgICAgICAvPFxcL1xcMVxccyo+Ly5zb3VyY2UsXG4gICAgICAgICAgMlxuICAgICAgICApKSArXG4gICAgICAnKSonICsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlZ2V4cC9zdHJpY3RcbiAgICAgIC88XFwvXFwxXFxzKj4vLnNvdXJjZSArXG4gICAgICAnfCcgK1xuICAgICAgLzwvLnNvdXJjZSArXG4gICAgICB0YWdDb250ZW50ICtcbiAgICAgICcpJyAvLyBOb3cgZm9yIHRoZSBhY3R1YWwgbGFuZ3VhZ2UgZGVmaW5pdGlvbihzKTpcbiAgICAvL1xuICAgIC8vIFJhem9yIGFzIGEgbGFuZ3VhZ2UgaGFzIDIgcGFydHM6XG4gICAgLy8gIDEpIENTSFRNTDogQSBtYXJrdXAtbGlrZSBsYW5ndWFnZSB0aGF0IGhhcyBiZWVuIGV4dGVuZGVkIHdpdGggaW5saW5lIEMjIGNvZGUgZXhwcmVzc2lvbnMgYW5kIGJsb2Nrcy5cbiAgICAvLyAgMikgQyMrSFRNTDogQSB2YXJpYW50IG9mIEMjIHRoYXQgY2FuIGNvbnRhaW4gQ1NIVE1MIHRhZ3MgYXMgZXhwcmVzc2lvbnMuXG4gICAgLy9cbiAgICAvLyBJbiB0aGUgYmVsb3cgY29kZSwgYm90aCBDU0hUTUwgYW5kIEMjK0hUTUwgd2lsbCBiZSBjcmVhdGUgYXMgc2VwYXJhdGUgbGFuZ3VhZ2UgZGVmaW5pdGlvbnMgdGhhdCByZWZlcmVuY2UgZWFjaFxuICAgIC8vIG90aGVyLiBIb3dldmVyLCBvbmx5IENTSFRNTCB3aWxsIGJlIGV4cG9ydGVkIHZpYSBgUHJpc20ubGFuZ3VhZ2VzYC5cbiAgICBQcmlzbS5sYW5ndWFnZXMuY3NodG1sID0gUHJpc20ubGFuZ3VhZ2VzLmV4dGVuZCgnbWFya3VwJywge30pXG4gICAgdmFyIGNzaGFycFdpdGhIdG1sID0gUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZShcbiAgICAgICdjc2hhcnAnLFxuICAgICAgJ3N0cmluZycsXG4gICAgICB7XG4gICAgICAgIGh0bWw6IHtcbiAgICAgICAgICBwYXR0ZXJuOiBSZWdFeHAodGFnUmVnaW9uKSxcbiAgICAgICAgICBncmVlZHk6IHRydWUsXG4gICAgICAgICAgaW5zaWRlOiBQcmlzbS5sYW5ndWFnZXMuY3NodG1sXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNzaGFycDogUHJpc20ubGFuZ3VhZ2VzLmV4dGVuZCgnY3NoYXJwJywge30pXG4gICAgICB9XG4gICAgKVxuICAgIHZhciBjcyA9IHtcbiAgICAgIHBhdHRlcm46IC9cXFNbXFxzXFxTXSovLFxuICAgICAgYWxpYXM6ICdsYW5ndWFnZS1jc2hhcnAnLFxuICAgICAgaW5zaWRlOiBjc2hhcnBXaXRoSHRtbFxuICAgIH1cbiAgICBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdjc2h0bWwnLCAncHJvbG9nJywge1xuICAgICAgJ3Jhem9yLWNvbW1lbnQnOiB7XG4gICAgICAgIHBhdHRlcm46IC9AXFwqW1xcc1xcU10qP1xcKkAvLFxuICAgICAgICBncmVlZHk6IHRydWUsXG4gICAgICAgIGFsaWFzOiAnY29tbWVudCdcbiAgICAgIH0sXG4gICAgICBibG9jazoge1xuICAgICAgICBwYXR0ZXJuOiBSZWdFeHAoXG4gICAgICAgICAgLyhefFteQF0pQC8uc291cmNlICtcbiAgICAgICAgICAgICcoPzonICtcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgLy8gQHsgLi4uIH1cbiAgICAgICAgICAgICAgY3VybHksIC8vIEBjb2RleyAuLi4gfVxuICAgICAgICAgICAgICAvKD86Y29kZXxmdW5jdGlvbnMpXFxzKi8uc291cmNlICsgY3VybHksIC8vIEBmb3IgKC4uLikgeyAuLi4gfVxuICAgICAgICAgICAgICAvKD86Zm9yfGZvcmVhY2h8bG9ja3xzd2l0Y2h8dXNpbmd8d2hpbGUpXFxzKi8uc291cmNlICtcbiAgICAgICAgICAgICAgICByb3VuZCArXG4gICAgICAgICAgICAgICAgL1xccyovLnNvdXJjZSArXG4gICAgICAgICAgICAgICAgY3VybHksIC8vIEBkbyB7IC4uLiB9IHdoaWxlICguLi4pO1xuICAgICAgICAgICAgICAvZG9cXHMqLy5zb3VyY2UgK1xuICAgICAgICAgICAgICAgIGN1cmx5ICtcbiAgICAgICAgICAgICAgICAvXFxzKndoaWxlXFxzKi8uc291cmNlICtcbiAgICAgICAgICAgICAgICByb3VuZCArXG4gICAgICAgICAgICAgICAgLyg/Olxccyo7KT8vLnNvdXJjZSwgLy8gQHRyeSB7IC4uLiB9IGNhdGNoICguLi4pIHsgLi4uIH0gZmluYWxseSB7IC4uLiB9XG4gICAgICAgICAgICAgIC90cnlcXHMqLy5zb3VyY2UgK1xuICAgICAgICAgICAgICAgIGN1cmx5ICtcbiAgICAgICAgICAgICAgICAvXFxzKmNhdGNoXFxzKi8uc291cmNlICtcbiAgICAgICAgICAgICAgICByb3VuZCArXG4gICAgICAgICAgICAgICAgL1xccyovLnNvdXJjZSArXG4gICAgICAgICAgICAgICAgY3VybHkgK1xuICAgICAgICAgICAgICAgIC9cXHMqZmluYWxseVxccyovLnNvdXJjZSArXG4gICAgICAgICAgICAgICAgY3VybHksIC8vIEBpZiAoLi4uKSB7Li4ufSBlbHNlIGlmICguLi4pIHsuLi59IGVsc2Ugey4uLn1cbiAgICAgICAgICAgICAgL2lmXFxzKi8uc291cmNlICtcbiAgICAgICAgICAgICAgICByb3VuZCArXG4gICAgICAgICAgICAgICAgL1xccyovLnNvdXJjZSArXG4gICAgICAgICAgICAgICAgY3VybHkgK1xuICAgICAgICAgICAgICAgICcoPzonICtcbiAgICAgICAgICAgICAgICAvXFxzKmVsc2UvLnNvdXJjZSArXG4gICAgICAgICAgICAgICAgJyg/OicgK1xuICAgICAgICAgICAgICAgIC9cXHMraWZcXHMqLy5zb3VyY2UgK1xuICAgICAgICAgICAgICAgIHJvdW5kICtcbiAgICAgICAgICAgICAgICAnKT8nICtcbiAgICAgICAgICAgICAgICAvXFxzKi8uc291cmNlICtcbiAgICAgICAgICAgICAgICBjdXJseSArXG4gICAgICAgICAgICAgICAgJykqJ1xuICAgICAgICAgICAgXS5qb2luKCd8JykgK1xuICAgICAgICAgICAgJyknXG4gICAgICAgICksXG4gICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgICAgaW5zaWRlOiB7XG4gICAgICAgICAga2V5d29yZDogL15AXFx3Ki8sXG4gICAgICAgICAgY3NoYXJwOiBjc1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGlyZWN0aXZlOiB7XG4gICAgICAgIHBhdHRlcm46XG4gICAgICAgICAgL14oWyBcXHRdKilAKD86YWRkVGFnSGVscGVyfGF0dHJpYnV0ZXxpbXBsZW1lbnRzfGluaGVyaXRzfGluamVjdHxsYXlvdXR8bW9kZWx8bmFtZXNwYWNlfHBhZ2V8cHJlc2VydmV3aGl0ZXNwYWNlfHJlbW92ZVRhZ0hlbHBlcnxzZWN0aW9ufHRhZ0hlbHBlclByZWZpeHx1c2luZykoPz1cXHMpLiovbSxcbiAgICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgICBpbnNpZGU6IHtcbiAgICAgICAgICBrZXl3b3JkOiAvXkBcXHcrLyxcbiAgICAgICAgICBjc2hhcnA6IGNzXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB2YWx1ZToge1xuICAgICAgICBwYXR0ZXJuOiBSZWdFeHAoXG4gICAgICAgICAgLyhefFteQF0pQC8uc291cmNlICtcbiAgICAgICAgICAgIC8oPzphd2FpdFxcYlxccyopPy8uc291cmNlICtcbiAgICAgICAgICAgICcoPzonICtcbiAgICAgICAgICAgIC9cXHcrXFxiLy5zb3VyY2UgK1xuICAgICAgICAgICAgJ3wnICtcbiAgICAgICAgICAgIHJvdW5kICtcbiAgICAgICAgICAgICcpJyArXG4gICAgICAgICAgICAnKD86JyArXG4gICAgICAgICAgICAvWz8hXT9cXC5cXHcrXFxiLy5zb3VyY2UgK1xuICAgICAgICAgICAgJ3wnICtcbiAgICAgICAgICAgIHJvdW5kICtcbiAgICAgICAgICAgICd8JyArXG4gICAgICAgICAgICBzcXVhcmUgK1xuICAgICAgICAgICAgJ3wnICtcbiAgICAgICAgICAgIGFuZ2xlICtcbiAgICAgICAgICAgIHJvdW5kICtcbiAgICAgICAgICAgICcpKidcbiAgICAgICAgKSxcbiAgICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgICBhbGlhczogJ3ZhcmlhYmxlJyxcbiAgICAgICAgaW5zaWRlOiB7XG4gICAgICAgICAga2V5d29yZDogL15ALyxcbiAgICAgICAgICBjc2hhcnA6IGNzXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAnZGVsZWdhdGUtb3BlcmF0b3InOiB7XG4gICAgICAgIHBhdHRlcm46IC8oXnxbXkBdKUAoPz08KS8sXG4gICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgIGFsaWFzOiAnb3BlcmF0b3InXG4gICAgICB9XG4gICAgfSlcbiAgICBQcmlzbS5sYW5ndWFnZXMucmF6b3IgPSBQcmlzbS5sYW5ndWFnZXMuY3NodG1sXG4gIH0pKFByaXNtKVxufVxuIl0sIm5hbWVzIjpbInJlZnJhY3RvckNzaGFycCIsInJlcXVpcmUiLCJtb2R1bGUiLCJleHBvcnRzIiwiY3NodG1sIiwiZGlzcGxheU5hbWUiLCJhbGlhc2VzIiwiUHJpc20iLCJyZWdpc3RlciIsImNvbW1lbnRMaWtlIiwic291cmNlIiwic3RyaW5nTGlrZSIsIm5lc3RlZCIsInBhdHRlcm4iLCJkZXB0aExvZzIiLCJpIiwicmVwbGFjZSIsInJvdW5kIiwic3F1YXJlIiwiY3VybHkiLCJhbmdsZSIsInRhZ0F0dHJzIiwidGFnQ29udGVudCIsInRhZ1JlZ2lvbiIsImxhbmd1YWdlcyIsImV4dGVuZCIsImNzaGFycFdpdGhIdG1sIiwiaW5zZXJ0QmVmb3JlIiwiaHRtbCIsIlJlZ0V4cCIsImdyZWVkeSIsImluc2lkZSIsImNzaGFycCIsImNzIiwiYWxpYXMiLCJibG9jayIsImpvaW4iLCJsb29rYmVoaW5kIiwia2V5d29yZCIsImRpcmVjdGl2ZSIsInZhbHVlIiwicmF6b3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/refractor/lang/cshtml.js\n"));

/***/ })

}]);